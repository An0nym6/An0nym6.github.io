<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-11-30T15:28:33-08:00</updated><id>/</id><title type="html">Random Thoughts</title><subtitle>Â©ï¸ Designed by shuq3 &amp; An0nym6</subtitle><entry><title type="html">ç®—æ³•æœŸæœ«å¤ä¹ ç¬”è®°</title><link href="/2018/11/29/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="ç®—æ³•æœŸæœ«å¤ä¹ ç¬”è®°" /><published>2018-11-29T20:00:00-08:00</published><updated>2018-11-29T20:00:00-08:00</updated><id>/2018/11/29/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/11/29/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯åº·å¥ˆå°”çš„ Algorithm Design å’Œ MIT çš„ Introduction to Algorithmsï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚&lt;/p&gt;

&lt;h4 id=&quot;lecture-5&quot;&gt;Lecture 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Steps for solving DP problems:
    &lt;ol&gt;
      &lt;li&gt;Describe subproblem;&lt;/li&gt;
      &lt;li&gt;Describe base case;&lt;/li&gt;
      &lt;li&gt;Describe recurrence;&lt;/li&gt;
      &lt;li&gt;Analyze complexity;&lt;/li&gt;
      &lt;li&gt;Write pseudo code.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-6&quot;&gt;Lecture 6&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Shortest path:
    &lt;ul&gt;
      &lt;li&gt;Single source &amp;amp; positive-weighted: Dijkstraâ€™s Algorithm;&lt;/li&gt;
      &lt;li&gt;Single source &amp;amp; negative-weighted: Bellman-Ford Algorithm;
        &lt;ul&gt;
          &lt;li&gt;Case 1: D[v, k] = D[v, k - 1], path uses at most k - 1 edges;&lt;/li&gt;
          &lt;li&gt;Case 2: D[v, k] = min&lt;sub&gt;(w, v)âˆˆE&lt;/sub&gt;(D[w, k - 1] + C&lt;sub&gt;wv&lt;/sub&gt;);&lt;/li&gt;
          &lt;li&gt;Goal: Compute D(t, v - 1);&lt;/li&gt;
          &lt;li&gt;Complexity: O(EV);&lt;/li&gt;
          &lt;li&gt;Negative cycle? Run 1 more round for k = v, if D decrease for some point, then yes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;All-pairs: 1. Run Bellman-Ford V times: O(EV&lt;sup&gt;2&lt;/sup&gt;); 2. Floyd-Warshall Algorithm;
        &lt;ul&gt;
          &lt;li&gt;D[i, j, k] = min&lt;sub&gt;u&lt;/sub&gt;(D[i, u, k - 1] + D[u, j, k - 1], D[i, j, k - 1]);&lt;/li&gt;
          &lt;li&gt;Pseudo code:
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  D[i,j,V[0]] = c[i,j] for all i and j
  for k in V:
    for i in V:
      for j in V:
        D[i,j,k] = min(D[i,k,k-1]+D[k,j,k-1],D[i,j,k-1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;Complexity: O(V&lt;sup&gt;3&lt;/sup&gt;)&lt;/li&gt;
          &lt;li&gt;Negative cycle? If the diagonal has nagetive elements, then yes;&lt;/li&gt;
          &lt;li&gt;Extract the shortest path? Every time we update D[i, j], we set P[i, j] to k. Then we recursively compute the shortest path from i to k = P[i, j] and the path from k = P[i, j] to j.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-7&quot;&gt;Lecture 7&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Max-flow problem: Ford-Fulkerson Algorithm:
    &lt;ul&gt;
      &lt;li&gt;Complexity: O(|f|(E + V));&lt;/li&gt;
      &lt;li&gt;Edmonds-Karp Algorithm: If we replace DFS with BFS, the complexity would be O(E&lt;sup&gt;2&lt;/sup&gt;V);&lt;/li&gt;
      &lt;li&gt;Capacity-Scaling Algorithm: If we choose the augmenting path with highest bottleneck capacity, the complexity would be O(log|f|E&lt;sup&gt;2&lt;/sup&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Max-flow theorem: the following conditions are equivalent for any f:
    &lt;ul&gt;
      &lt;li&gt;âˆƒ cut(A, B) s.t. cap(A, B) = |f|;&lt;/li&gt;
      &lt;li&gt;f is a max-flow;&lt;/li&gt;
      &lt;li&gt;There is no augmenting path wrt to f.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Value of the max-flow = capacity of the min-cut.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Applications of max-flow:
    &lt;ul&gt;
      &lt;li&gt;Bipartite max matching: |f| â‰¤ V, Vâ€™ = 2V, so complexity: O(V(E + 2V)) = O(EV).&lt;/li&gt;
      &lt;li&gt;Maximum number of edge disjoint paths. Complexity: O(EV)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-8&quot;&gt;Lecture 8&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Image segmentation problem: solved by min-cut problem.&lt;/li&gt;
  &lt;li&gt;Circulation problem can be reduced to max-flow problem: there is a feasible circulation in G if and only if the max-flow can achieve Î£&lt;sub&gt;d(v)&amp;gt;0&lt;/sub&gt;d(v).&lt;/li&gt;
  &lt;li&gt;Circulation problem with demands can be reduced to circulation problem without demands: just push the lower bounds of flow through each edges, then modify the capacity of each edge and demand of each vertex respectively.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Survey Design Problem.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-9&quot;&gt;Lecture 9&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Undecidable problems: there is no computer program that can always give the right answer: it may give the wrong answer, or run forever. NP-Hard contains undecidable problems.
    &lt;ul&gt;
      &lt;li&gt;Example: The halting problem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;To prove X is in NP-Complete, we first prove X is in NP (answer can be verified in polynomial time), then we prove X is in NP-Hard (âˆƒY âˆˆ NP, Y â‰¤&lt;sub&gt;p&lt;/sub&gt; X).&lt;/li&gt;
  &lt;li&gt;NP-Complete problems are the most difficult NP problems.&lt;/li&gt;
  &lt;li&gt;Reductions of NP-Complete problems:
    &lt;ul&gt;
      &lt;li&gt;SAT is in NP-Complete without proof;&lt;/li&gt;
      &lt;li&gt;3-SAT â‰¤&lt;sub&gt;p&lt;/sub&gt; Independent set;&lt;/li&gt;
      &lt;li&gt;Independent set â‰¤&lt;sub&gt;p&lt;/sub&gt; Vertex cover;&lt;/li&gt;
      &lt;li&gt;Vertex cover â‰¤&lt;sub&gt;p&lt;/sub&gt; Vertex cover-even;&lt;/li&gt;
      &lt;li&gt;3-SAT â‰¤&lt;sub&gt;p&lt;/sub&gt; 3-colorable;&lt;/li&gt;
      &lt;li&gt;3-SAT â‰¤&lt;sub&gt;p&lt;/sub&gt; Hamiltonian Cycle (without proof).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-10&quot;&gt;Lecture 10&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Standard linear programming problem in matrix form:&lt;br /&gt;
 max(c&lt;sup&gt;T&lt;/sup&gt;x),&lt;br /&gt;
 subject to: Ax â‰¤ b, x â‰¥ 0.
    &lt;ul&gt;
      &lt;li&gt;Linear programming can be used to solve max-flow and shortest path problem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Integer linear programming (ILP) is in NP-Hard.
    &lt;ul&gt;
      &lt;li&gt;Independent set â‰¤&lt;sub&gt;p&lt;/sub&gt; ILP;&lt;/li&gt;
      &lt;li&gt;ILP can be used to solve 0-1 Knapsack.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The dual of standard linear programming problem:&lt;br /&gt;
 min(b&lt;sup&gt;T&lt;/sup&gt;y),&lt;br /&gt;
 subject to: A&lt;sup&gt;T&lt;/sup&gt;y â‰¥ c, y â‰¥ 0.
    &lt;ul&gt;
      &lt;li&gt;The weak duality: if x is a feasible solution for primal and y is a feasible solution for dual, then c&lt;sup&gt;T&lt;/sup&gt;x â‰¤ b&lt;sup&gt;T&lt;/sup&gt;y;&lt;/li&gt;
      &lt;li&gt;The strong duality: opt(primal) = opt(dual);&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;P \ D&lt;/th&gt;
              &lt;th&gt;F.B.&lt;/th&gt;
              &lt;th&gt;F.U.&lt;/th&gt;
              &lt;th&gt;I.&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;F.B.&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;F.U.&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;I.&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;General form of primal and dual:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Primal&lt;/th&gt;
          &lt;th&gt;Dual&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;max(c&lt;sup&gt;T&lt;/sup&gt;x)&lt;/td&gt;
          &lt;td&gt;min(b&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;1&lt;/sub&gt; + b&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;2&lt;/sub&gt; + b&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;3&lt;/sub&gt;)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A&lt;sub&gt;1&lt;/sub&gt;x â‰¤ b&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
          &lt;td&gt;A&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;1&lt;/sub&gt; + A&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;2&lt;/sub&gt; + A&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;3&lt;/sub&gt; â‰¥ c&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A&lt;sub&gt;2&lt;/sub&gt;x = b&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;
          &lt;td&gt;y&lt;sub&gt;1&lt;/sub&gt; â‰¥ 0&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A&lt;sub&gt;3&lt;/sub&gt;x â‰¥ b&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
          &lt;td&gt;y&lt;sub&gt;2&lt;/sub&gt; unrestricted&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;x â‰¥ 0&lt;/td&gt;
          &lt;td&gt;y&lt;sub&gt;3&lt;/sub&gt; â‰¤ 0&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-11&quot;&gt;Lecture 11&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Classic approximation algorithms:
    &lt;ul&gt;
      &lt;li&gt;2-approximation vertex cover: find matchings in graph;&lt;/li&gt;
      &lt;li&gt;2-approximation TSP on complete graph with triangle inequality: use MST;&lt;/li&gt;
      &lt;li&gt;1.5-approximation TSP on complete graph with triangle inequality:
        &lt;ul&gt;
          &lt;li&gt;MST of G â†’ T;&lt;/li&gt;
          &lt;li&gt;Vertices of odd degree in T â†’ S;&lt;/li&gt;
          &lt;li&gt;Min-cost matching on S â†’ M;&lt;/li&gt;
          &lt;li&gt;return T âˆª M.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;There is no polynomial Î±-approximation algorithm for general TSP: if such algorithm exists, we can use it to solve Hamiltonian Cycle.&lt;/li&gt;
      &lt;li&gt;ln n-approximation set cover: greedy, each move covers at least 1/k of the elements, so k * ln n moves will cover all (k is the optimal).&lt;/li&gt;
      &lt;li&gt;2-approximation load balance: greedy: assign next job to the machine with least load.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-12&quot;&gt;Lecture 12&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Classification of random algorithm:
    &lt;ul&gt;
      &lt;li&gt;Las Vegas algorithms: always returns the correct answer, but may run longer than you expect.
        &lt;ul&gt;
          &lt;li&gt;Example: quick sort.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Monte Carlo algorithms: may fail or return incorrect answer, but the runtime is independent of input randomness.
        &lt;ul&gt;
          &lt;li&gt;Example: random global min-cut.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Random data structre:
    &lt;ul&gt;
      &lt;li&gt;Skip list: O(log n) search time;&lt;/li&gt;
      &lt;li&gt;Treap: a binary search tree with the heap ordering property (use rotation to maintain heap ordering property while do no change to BST ordering property).
        &lt;ul&gt;
          &lt;li&gt;Complexity: O(log n) search time &amp;amp; O(log n) insert time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="å­¦ä¹ ç¬”è®°" /><summary type="html">è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯åº·å¥ˆå°”çš„ Algorithm Design å’Œ MIT çš„ Introduction to Algorithmsï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚</summary></entry><entry><title type="html">AI ç¬¬ä¸‰éƒ¨åˆ†â€œæœºå™¨å­¦ä¹ â€å¤ä¹ ç¬”è®°</title><link href="/2018/11/24/AI-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="AI ç¬¬ä¸‰éƒ¨åˆ†â€œæœºå™¨å­¦ä¹ â€å¤ä¹ ç¬”è®°" /><published>2018-11-24T20:00:00-08:00</published><updated>2018-11-24T20:00:00-08:00</updated><id>/2018/11/24/AI%20%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%9D%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/11/24/AI-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯ Artificial Intelligence: A Modern Approachï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚&lt;/p&gt;

&lt;h4 id=&quot;lecture-18-19&quot;&gt;Lecture 18-19&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Bayesâ€™ rule: P(A|B) = (P(B|A) Â· P(A)) / P(B).&lt;/li&gt;
  &lt;li&gt;Normalization &amp;amp; marginalization: P(X|e) = P(X, e) / P(e) = Î± Â· P(X, e) = Î± Â· Î£&lt;sub&gt;y&lt;/sub&gt; P(X, e, y).&lt;/li&gt;
  &lt;li&gt;In the alarm network, calls are conditionally independent of burglaries and earthquakes, but not independent of them.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-20&quot;&gt;Lecture 20&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Entropy: -Î£&lt;sub&gt;i&lt;/sub&gt; P(v&lt;sub&gt;i&lt;/sub&gt;) Â· ln(P(v&lt;sub&gt;i&lt;/sub&gt;)):
    &lt;ul&gt;
      &lt;li&gt;The more uniform the probability distribution, the greater its information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ID3 algorithm: Top-down construction of decision tree by recursively selecting â€œbest attributeâ€ to use at the current node in tree.
    &lt;ul&gt;
      &lt;li&gt;â€œbest attributeâ€: Choose the attribute that has the largest expected information gain.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-20-21&quot;&gt;Lecture 20-21&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Back-propagation is synchronous while Hopfield net is asynchronous; Back-propagation tries to minimize the error while Hopfield net tries to minimize the energy.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-22&quot;&gt;Lecture 22&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Markov Decision Process (MDP):
    &lt;ul&gt;
      &lt;li&gt;The problem is to find the optimal policy, which maximizes utility at each state;&lt;/li&gt;
      &lt;li&gt;Bellman equation: U(s) = R(s) + Î³ max&lt;sub&gt;a&lt;/sub&gt;(Î£&lt;sub&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/sub&gt;(P(s&lt;sub&gt;1&lt;/sub&gt; | s, a) Â· U(s&lt;sub&gt;1&lt;/sub&gt;))). Repeating this formula will converge to optimal policy.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-23&quot;&gt;Lecture 23&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Reinforcement Learning:
    &lt;ul&gt;
      &lt;li&gt;Utility-based agent: if it already knows the transition model, then use MDP algorithm to solve for Maximum Expectation Utility (MEU) actions.&lt;/li&gt;
      &lt;li&gt;Q-learning agent: if it doesnâ€™t know the transition model, then pick action that has highest utility in current state.&lt;br /&gt;
        &lt;ul&gt;
          &lt;li&gt;Q(s, a) = Q(s, a) + Î±(R(s) + Î³ max&lt;sub&gt;aâ€™&lt;/sub&gt; (Q(sâ€™, aâ€™) âˆ’ Q(s, a))) â†’&lt;br /&gt;
  Q(s, a) = (1 - Î±)Q(s, a) + Î±(R(s) + Î³ max&lt;sub&gt;aâ€™&lt;/sub&gt; Q(sâ€™, aâ€™))&lt;/li&gt;
          &lt;li&gt;Converge to correct values if Î± decays over time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Reflex agent: learn a policy directly, then pick the action that the policy says.
        &lt;ul&gt;
          &lt;li&gt;Can start right away and then learn as it goes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-24-25&quot;&gt;Lecture 24-25&lt;/h4&gt;

&lt;p&gt;Guest speaker.&lt;/p&gt;

&lt;h4 id=&quot;lecture-26&quot;&gt;Lecture 26&lt;/h4&gt;

&lt;p&gt;ğŸº&lt;/p&gt;</content><author><name></name></author><category term="å­¦ä¹ ç¬”è®°" /><summary type="html">è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯ Artificial Intelligence: A Modern Approachï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚</summary></entry><entry><title type="html">AI ç¬¬äºŒéƒ¨åˆ†â€œé€»è¾‘â€å¤ä¹ ç¬”è®°</title><link href="/2018/10/26/AI-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%80%BB%E8%BE%91-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="AI ç¬¬äºŒéƒ¨åˆ†â€œé€»è¾‘â€å¤ä¹ ç¬”è®°" /><published>2018-10-26T21:00:00-07:00</published><updated>2018-10-26T21:00:00-07:00</updated><id>/2018/10/26/AI%20%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E2%80%9C%E9%80%BB%E8%BE%91%E2%80%9D%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/10/26/AI-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%80%BB%E8%BE%91-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯ Artificial Intelligence: A Modern Approachï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚&lt;/p&gt;

&lt;h4 id=&quot;lecture-9-10&quot;&gt;Lecture 9-10&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Syntax (è¯­æ³•): how sentences are expressed; semantics (è¯­ä¹‰): meaning of the sentence, e.g., truth value.&lt;/li&gt;
  &lt;li&gt;If a sentence Î± is true in model m, we say m satisfies Î±, or m is a model of Î±:
    &lt;ul&gt;
      &lt;li&gt;M(Î±) is the set of all models of Î±; M(KB) is the set of all models of KB;&lt;/li&gt;
      &lt;li&gt;KB âŠ¨ Î± if and only if M(KB) is a subset M(Î±).&lt;/li&gt;
      &lt;li&gt;KB âŠ¨ Î±: KB entails sentence Î±, if and only if, Î± is true in all worlds where KB is true.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Entailment (âŠ¨) is different from inference (âŠ¢). Think of inference a the process of finding the entailment:
    &lt;ul&gt;
      &lt;li&gt;KB âŠ¢i Î± = sentence Î± can be derived from KB by procedure i.&lt;/li&gt;
      &lt;li&gt;Soundness: i is sound if whenever KB âŠ¢i Î±, it is also true that KB âŠ¨ Î±.&lt;/li&gt;
      &lt;li&gt;Completeness: i is complete if whenever KB âŠ¨ Î±, it is also true that KB âŠ¢i Î±.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Proof methods:
    &lt;ol&gt;
      &lt;li&gt;Model checking: Truth table enumeration (sound and complete); Heuristic search in model space (sound but incomplete);&lt;/li&gt;
      &lt;li&gt;Application of inference rules.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;A sentence is valid if it is true in all models (tautologies); A sentence is satisfiable if it is true in at least one model.
    &lt;ul&gt;
      &lt;li&gt;Î± is valid if and only if Â¬Î± is unsatisfiable;&lt;/li&gt;
      &lt;li&gt;Î± is satisfiable if and only if Â¬Î± is not valid.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Names for important tautologies:
    &lt;ul&gt;
      &lt;li&gt;Commutativity of â‹€ / â‹: äº¤æ¢å¾‹&lt;/li&gt;
      &lt;li&gt;Associativity of â‹€ / â‹: ç»“åˆå¾‹&lt;/li&gt;
      &lt;li&gt;Double-negation elimination&lt;/li&gt;
      &lt;li&gt;Contraposition: Î± â‡’ Î² â‡” Â¬Î² â‡’ Â¬Î±&lt;/li&gt;
      &lt;li&gt;Implication elimination&lt;/li&gt;
      &lt;li&gt;Biconditional elimination&lt;/li&gt;
      &lt;li&gt;De Morgan&lt;/li&gt;
      &lt;li&gt;Distributivity of â‹€ / â‹ over â‹ / â‹€: åˆ†é…å¾‹&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Î± âŠ¨ Î² if and only if the sentence (Î± â‹€ Â¬Î²) is unsatisfiable.&lt;/li&gt;
  &lt;li&gt;Names for inference rules:
    &lt;ul&gt;
      &lt;li&gt;Modus ponens: from Î± â‡’ Î², Î±, we get Î²&lt;/li&gt;
      &lt;li&gt;Modus tollens: from Î± â‡’ Î², Â¬Î², we get Â¬Î±&lt;/li&gt;
      &lt;li&gt;And-elimination: from Î± â‹€ Î², we get Î±&lt;/li&gt;
      &lt;li&gt;Or-introduction: from Î±, we get Î± â‹ Î²&lt;/li&gt;
      &lt;li&gt;Both directions of all tautologies like contraposition: (Î± â‡’ Î²) â‡” (Â¬Î² â‡’ Â¬Î±)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-11-12&quot;&gt;Lecture 11-12&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Resolution Inference: Complete when coupled with complete search algorithm.
    &lt;ul&gt;
      &lt;li&gt;To prove that KB âŠ¨ Î±, we show that (KB â‹€ Â¬Î±) is unsatisfiable:
        &lt;ol&gt;
          &lt;li&gt;Convert (KB â‹€ Â¬Î±) to CNF;&lt;/li&gt;
          &lt;li&gt;Apply the resolution rule wherever possible and add the result as an additional clause in the conjunction;&lt;/li&gt;
          &lt;li&gt;Repeat step 2 until either:
            &lt;ul&gt;
              &lt;li&gt;No new clauses can be added: KB does not entail Î±.&lt;/li&gt;
              &lt;li&gt;Two clauses resolve to yield the empty clause: KB entails Î±.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If each clause is a horn clause in KB and the queries are atomic, then we can use linear-time algorithm forward chaining and backward chaining to do the inference. Complexity for backward chaining can be much less than linear in size of KB.&lt;/li&gt;
  &lt;li&gt;Symbols for constants, predicates and functions usually start with upper-case letters; Variables are written in lowercase letters.&lt;/li&gt;
  &lt;li&gt;â‡’ is a natural connective to use with âˆ€; â‹€ is a natural connective to use with âˆƒ.&lt;/li&gt;
  &lt;li&gt;De Morgan for quantifier negation: Â¬âˆ€x P â‡” âˆƒx Â¬P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-13&quot;&gt;Lecture 13&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A ground literalâ€™s terms are all ground terms; A ground term is a term without variables.&lt;/li&gt;
  &lt;li&gt;SUBST(Î¸, Î±): rewrite a sentence, Î±, by applying substitution, Î¸.&lt;/li&gt;
  &lt;li&gt;For every unifiable pair of expressions there is a Most General Unifier (a unique substitution) that equates the pair while making the fewest restrictions on the values of the variables.&lt;/li&gt;
  &lt;li&gt;First-order definite clauses are disjunctions of literals, of which exactly one is positive:
    &lt;ul&gt;
      &lt;li&gt;Atomic sentences (positive literals) are also definite clauses;&lt;/li&gt;
      &lt;li&gt;Definite clauses can include variables. The variables are assumed to be universally quantified.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datalog Knowledge base contains only first-order definite clauses with no function symbols.&lt;/li&gt;
  &lt;li&gt;Forward chaining is sound and complete for first-order definete clauses. We can use CSP heuristics like Minimum-Remaining Value to imporve efficiency. We can also do incremental forward chaining â€“ only consider rules with premise that involves a literal that can unify with the facts newly inferred from the previous iteration.&lt;/li&gt;
  &lt;li&gt;Backward chaining is sound but incomplete due to infinite loops. But itâ€™s linear in size of proof.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-14&quot;&gt;Lecture 14&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Herbrandâ€™s theorem: If there is a proof that a sentence is entailed by the original first-order knowledge base, then there is a proof involving just a finite subset of the propositionalized knowledge base. Entailment for first-order logic is semidecidable. We can say yes to every entailed sentence, but there is no way to say no to every non-entailed sentence.&lt;/li&gt;
  &lt;li&gt;CNF conversion for first-order logic:
    &lt;ol&gt;
      &lt;li&gt;Eliminate implications;&lt;/li&gt;
      &lt;li&gt;Move Â¬ inward;&lt;/li&gt;
      &lt;li&gt;Standardize variables;&lt;/li&gt;
      &lt;li&gt;Skolemization;
        &lt;ul&gt;
          &lt;li&gt;Unique function names;&lt;/li&gt;
          &lt;li&gt;Arguments for all of the universally quantified variables in whose scope the existential quantifier appears;&lt;/li&gt;
          &lt;li&gt;We used Skolem Constants to remove existential quantifiers when the sentence was in a specific form (å­˜åœ¨é‡è¯åœ¨æœ€å¤–é¢);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Drop universal quantifiers;&lt;/li&gt;
      &lt;li&gt;Distribute â‹ over â‹€.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Russellâ€™s Paradox:
    &lt;ul&gt;
      &lt;li&gt;The paradox arises within naive set theory by considering the set of all sets that are not members of themselves.&lt;/li&gt;
      &lt;li&gt;A master catalog of all library catalogs which do not include themselves.&lt;/li&gt;
      &lt;li&gt;A barber who shaves exactly those people who do not shave themselves.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Prolog.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(ä¸çŸ¥é“ä¸ºä»€ä¹ˆæ²¡æœ‰ Lecture 15)&lt;/p&gt;

&lt;h4 id=&quot;lecture-16&quot;&gt;Lecture 16&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Knowledge engineering is declarative (not procedural).&lt;/li&gt;
  &lt;li&gt;Propositional and first-order logic are monotonic:
    &lt;ul&gt;
      &lt;li&gt;As new sentences Î± are added to KB what is entailed can never decrease.&lt;/li&gt;
      &lt;li&gt;Non-monotonic logic eliminates this restriction.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4 efforts of knowledge sharing:
    &lt;ul&gt;
      &lt;li&gt;Knowledge Interchange Format (KIF): Translate from KB1 to KIF then to KB2;&lt;/li&gt;
      &lt;li&gt;Knowledge Representation System Specification: Create â€œstandardâ€ specification for KR language within a particular family of languages;&lt;/li&gt;
      &lt;li&gt;Standardized Query Interface: Share across KBs by querying from one KB to the other (as in databases);&lt;/li&gt;
      &lt;li&gt;Shared, Reusable Knowledge Bases: Create a common â€œupperâ€ ontology that can form the basis for many knowledge based systems.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4 possible KRR (knowledge representation and reasoning) approaches:
    &lt;ul&gt;
      &lt;li&gt;Knowledge engineering: Write down all of the necessary knowledge in a manner that supports automated inference;
        &lt;ul&gt;
          &lt;li&gt;Cyc / OpenMind Common Sense&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Semantic web: Distribute the knowledge engineering task across the entire world, supported by international standards for encoding knowledge;
        &lt;ul&gt;
          &lt;li&gt;WikiData&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Knowledge extraction: Find knowledge in natural language text (e.g. social media), and convert it into a representation that supports automated reasoning;
        &lt;ul&gt;
          &lt;li&gt;Hearst Patterns / Commonsense axioms from text&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Experiential learning: Build a robot that can learn the knowledge by interacting with the world, just like a human child does;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-17&quot;&gt;Lecture 17&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Situation Calculus:
    &lt;ul&gt;
      &lt;li&gt;Situations: Each time step is a â€œsituationâ€. A function Result(a, s) gives the situation resulting from applying action a in situation s;&lt;/li&gt;
      &lt;li&gt;Fluents: Functions &amp;amp; predicates whose truth values can change from one situation to the other;&lt;/li&gt;
      &lt;li&gt;Atemporal (or eternal) predicates and functions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Classical issues:
    &lt;ul&gt;
      &lt;li&gt;Frame problem: Representing all things that stay the same from one situation to the next;&lt;/li&gt;
      &lt;li&gt;Qualification problem: Defining the circumstances under which an action is guaranteed to work;&lt;/li&gt;
      &lt;li&gt;Ramification problem: Proliferation of implicit consequences of actions as actions may have secondary consequences.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;STRIPS-style planning:
    &lt;ul&gt;
      &lt;li&gt;Representing states:
        &lt;ul&gt;
          &lt;li&gt;A conjunction of positive literals (must be grounded and function free);&lt;/li&gt;
          &lt;li&gt;Closed world assumption: If not explicitly mentioned as true, assumed false.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Representing goals:
        &lt;ul&gt;
          &lt;li&gt;Generally a partial state specification (still must be positive, grounded and function free);&lt;/li&gt;
          &lt;li&gt;A goal is satisfied if state contains all literals in goal.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Representing actions:
        &lt;ul&gt;
          &lt;li&gt;An action is specified by a name, a list of parameters, a precondition and an effect:
            &lt;ul&gt;
              &lt;li&gt;PRECOND: Must be true in state for action to execute (conjunction of function-free positive literals);&lt;/li&gt;
              &lt;li&gt;EFFECT: Changes to state when action executes (conjunction of function-free literals); Positive literals add facts, negated literals remove facts.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Assumption: Every literal not modified by EFFECT remains unchanged to avoids representational frame problem.&lt;/li&gt;
      &lt;li&gt;Planning Domain Definition Language (PDDL) is slightly more expressive (allows negative literals in goals and preconditions):
        &lt;ul&gt;
          &lt;li&gt;Neither language allows functions;&lt;/li&gt;
          &lt;li&gt;Neither deals with the ramification problem;&lt;/li&gt;
          &lt;li&gt;Neither deals with the qualification problem.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Forward: Progression planner / Backward: Regression planner. Both progression and regression are still NP-hard.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Partial-order planning (POP):
    &lt;ul&gt;
      &lt;li&gt;Each plan has 4 components:
        &lt;ul&gt;
          &lt;li&gt;A set of actions (steps in the plan);&lt;/li&gt;
          &lt;li&gt;A set of ordering constraints: A &amp;lt; B (A before B);&lt;/li&gt;
          &lt;li&gt;A set of causal links (protection intervals);&lt;/li&gt;
          &lt;li&gt;A set of open preconditions (goals).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Planning graph:
    &lt;ul&gt;
      &lt;li&gt;A planning graph consists of a sequence of levels that correspond to steps in the plan; each level consists of a set of literals and a set of actions:
        &lt;ul&gt;
          &lt;li&gt;Literals = all those that could be true at that time step, based on the actions executed at preceding time steps;&lt;/li&gt;
          &lt;li&gt;Actions = all those actions that could have their preconditions satisfied at that time step, based on which literals actually hold;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Connect preconditions of actions in A0 to S0 and effects to S1; Inaction is represented by persistence actions (like frame axioms);&lt;/li&gt;
      &lt;li&gt;Conflicts:
        &lt;ul&gt;
          &lt;li&gt;A mutex relation holds between two actions when:
            &lt;ul&gt;
              &lt;li&gt;Inconsistent effects: one action negates the effect of another;&lt;/li&gt;
              &lt;li&gt;Interference: an effect of one action negates a precondition of the other;&lt;/li&gt;
              &lt;li&gt;Competing needs: a precondition of one action is mutually exclusive with a precondition of the other;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;A mutex relation holds between two literals when:
            &lt;ul&gt;
              &lt;li&gt;One is the negation of the other;&lt;/li&gt;
              &lt;li&gt;Each possible action pair that could achieve the literals is mutex;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Stop when two consecutive levels are identical; complexity is polynomial.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="å­¦ä¹ ç¬”è®°" /><summary type="html">è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯ Artificial Intelligence: A Modern Approachï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚</summary></entry><entry><title type="html">ç®—æ³•æœŸä¸­å¤ä¹ ç¬”è®°</title><link href="/2018/10/09/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="ç®—æ³•æœŸä¸­å¤ä¹ ç¬”è®°" /><published>2018-10-09T21:00:00-07:00</published><updated>2018-10-09T21:00:00-07:00</updated><id>/2018/10/09/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/10/09/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯åº·å¥ˆå°”çš„ Algorithm Design å’Œ MIT çš„ Introduction to Algorithmsï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚&lt;/p&gt;

&lt;h4 id=&quot;lecture-1&quot;&gt;Lecture 1&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;we say f(n) = O(g(n)) if g(n) eventually dominates f(n). Formally: there exists a constant c such that for all sufficiently large n: f(n) â‰¤ c * g(n). The definition for Î© is similar to the definition for O. If f(n) = O(g(n)) and f(n) = Î©(g(n)), then f(n) = Î˜(g(n)).
    &lt;ul&gt;
      &lt;li&gt;(1/3)^n + 100 = O(1) is True.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The handshaking theorem: 2 * E = Î£xâˆˆV deg(x) (undirected graph)&lt;/li&gt;
  &lt;li&gt;Adjacency List Representation is used for representation of the sparse (E = O(V)) graphs; Adjacency Matrix Representation is used for representation of the dense (E = Î©(V^2)) graphs.
    &lt;ul&gt;
      &lt;li&gt;Maximally sparse connected graph: tree;&lt;/li&gt;
      &lt;li&gt;Maximally dense connected graph: complete graph Kn.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Linear time topological sort for DAG algorithm:
    &lt;ul&gt;
      &lt;li&gt;Select a vertex;&lt;/li&gt;
      &lt;li&gt;Run DFS and return vertices that has no undiscovered leaving edges;&lt;/li&gt;
      &lt;li&gt;May run DFS several times.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Is strongly connected graphs:
    &lt;ul&gt;
      &lt;li&gt;Select a vertex;&lt;/li&gt;
      &lt;li&gt;Run DFS, if some vertices are not reachable, stop;&lt;/li&gt;
      &lt;li&gt;Construct GT and run DFS again, if some vertices are not reachable, stop.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Eulerâ€™s Formula: If G is a connected planar graph, then V â€“ E + F = 2 (proof is by induction).&lt;/li&gt;
  &lt;li&gt;4 Color Theorem: Any simple planar graph can be colored with less than or equal to 4 colors.&lt;/li&gt;
  &lt;li&gt;A graph is bipartite if the vertices can be partitioned into two disjoint sets. A subset of edges is a matching if no two edges have a common vertex.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-2&quot;&gt;Lecture 2&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Complete Binary Tree: completely filled, except the bottom level that is filled from left to right; and a binary heap is a complete binary tree which satisfies the heap ordering property.&lt;/li&gt;
  &lt;li&gt;In heap, consider the k-th element of the array:
    &lt;ul&gt;
      &lt;li&gt;Its left child is located at 2 * k index;&lt;/li&gt;
      &lt;li&gt;Its right child is located at 2 * k + 1 index;&lt;/li&gt;
      &lt;li&gt;Its parent is located at k / 2 index.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap operations:
    &lt;ul&gt;
      &lt;li&gt;Insert: insert at the end, then percolate it up by swapping positions with the parent, if itâ€™s necessary;&lt;/li&gt;
      &lt;li&gt;deleteMin: move the last element of the heap to the root and then restore the heap property by percolating down; So the complexity for heap sort is O(n * log n)&lt;/li&gt;
      &lt;li&gt;decreaseKey: restore a heap property by percolating up this item;&lt;/li&gt;
      &lt;li&gt;buildHeap: by insertion: O(n * log n); heapify: O(n).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Binomial heap operations:
    &lt;ul&gt;
      &lt;li&gt;merge: make the larger root to be the child of the smaller root. Complexity: O(log n);&lt;/li&gt;
      &lt;li&gt;deleteMin: find the binomial tree that contains the min; delete the root and move subtrees to top list; then merge the binomial trees. Complexity: O(log n);&lt;/li&gt;
      &lt;li&gt;insert: merge trees.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Amortized analysis gives the average performance (over time) of each operation in the worst case.
    &lt;ul&gt;
      &lt;li&gt;The amortized cost of insertion of Binomial heap is constant O(2).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Complexities:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Â &lt;/th&gt;
      &lt;th&gt;Binary&lt;/th&gt;
      &lt;th&gt;Binomial&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;findMin&lt;/td&gt;
      &lt;td&gt;Î˜(1)&lt;/td&gt;
      &lt;td&gt;Î˜(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;deleteMin&lt;/td&gt;
      &lt;td&gt;Î˜(log n)&lt;/td&gt;
      &lt;td&gt;Î˜(log n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;insert&lt;/td&gt;
      &lt;td&gt;Î˜(log n)&lt;/td&gt;
      &lt;td&gt;Î˜(1) (amortized complexity)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;decreaseKey&lt;/td&gt;
      &lt;td&gt;Î˜(log n)&lt;/td&gt;
      &lt;td&gt;Î˜(log n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;merge&lt;/td&gt;
      &lt;td&gt;Î˜(n)&lt;/td&gt;
      &lt;td&gt;Î˜(log n)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;lecture-3&quot;&gt;Lecture 3&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Scheduling Problem: early finish time first. Complexity: O(n * log n).&lt;/li&gt;
  &lt;li&gt;Minimum Spanning Tree:
    &lt;ul&gt;
      &lt;li&gt;Kruskalâ€™s Algorithm: Continue choosing the minimum weight edge that will not create a cycle until all vertices are connected.
        &lt;ul&gt;
          &lt;li&gt;Sorting edges: O(E * log E);&lt;/li&gt;
          &lt;li&gt;Cycle detection: O(V);&lt;/li&gt;
          &lt;li&gt;Total: O(E * log E + E * V).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Primâ€™s Algorithm: Start with an arbitrary vertex as a sub-tree C; Expand C by adding a vertex having the minimum weight edge of the graph having exactly one end point in C; Update distances from C to adjacent vertices; Continue doing this until all vertices are connected.
        &lt;ul&gt;
          &lt;li&gt;If we use an array to maintain vertices distance to C, then findMin / deleteMin needs O(V), and update needs O(1). Complexity: O(V ^ 2 + E);&lt;/li&gt;
          &lt;li&gt;If we use a heap, then findMin / deleteMin needs O(log V), and update needs O(log V). Complexity: O(V * log V + E * log V);&lt;/li&gt;
          &lt;li&gt;If graph is dense -&amp;gt; array; if graph is sparse -&amp;gt; heap.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;If a connected undirected graph G = (V, E) has V + 10000 edges, we can find an MST of G in O(V) runtime.
        &lt;ul&gt;
          &lt;li&gt;True. Randomly generate a spanning tree (O(n)), for each edge in the last 10000 edges, add it to the tree, delete the max edge in the cycle (O(n)). So the total complexity should be 10000 * O(n) = O(n).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The Shortest Path Problem:
    &lt;ul&gt;
      &lt;li&gt;Dijkstraâ€™s Algorithm: almost identical to Primâ€™s algorithm, but picks the shortest path from the source. Itâ€™s complexity is same as Primâ€™s Algorithm.
        &lt;ul&gt;
          &lt;li&gt;If priority queue is an array: O(V ^ 2 + E);&lt;/li&gt;
          &lt;li&gt;If priority queue is a heap: O(V * log V + E * log V);&lt;/li&gt;
          &lt;li&gt;If graph is dense (E = V ^ 2) -&amp;gt; array O(V ^ 2); if graph is sparse -&amp;gt; heap O(V * log V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-4&quot;&gt;Lecture 4&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The Master Theorem: T(n) = a * T(n / b) + f(n), where a â‰¥ 1 and b &amp;gt; 1 are constants and f(n) is a positive function, c = logb(a):
    &lt;ul&gt;
      &lt;li&gt;Case 1: if f(n) = O(n^(c-Îµ)), then T(n) = Î˜(n ^ c); (only leaves)&lt;/li&gt;
      &lt;li&gt;Case 2: if f(n) = Î˜(n^c * (log n) ^ k), k â‰¥ 0, then T(n) = Î˜(n^c * (log n)^(k + 1)); (all nodes)&lt;/li&gt;
      &lt;li&gt;Case 3: if f(n) = Î©(n^(c+Îµ)), then T(n) = Î˜(f(n)); (only internal nodes)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Closest pair of points: T(n) = 2 * T(n / 2) + O(n * log n), so the complexity should be Î˜(n * (log n) ^ 2)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-5&quot;&gt;Lecture 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Two Approaches for DP:
    &lt;ul&gt;
      &lt;li&gt;Memoization: a top-down approach;&lt;/li&gt;
      &lt;li&gt;Tabulation: a bottom-up approach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pseudo-Polynomial Algorithm: A numeric algorithm runs in pseudo-polynomial time if its running time is polynomial in the numeric value of the input, but is exponential in the length of the input: T(n) = Î˜(nÂ·W).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-6&quot;&gt;Lecture 6&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Basic steps for DP:
    &lt;ul&gt;
      &lt;li&gt;Define subproblems;&lt;/li&gt;
      &lt;li&gt;Write the recurrence relation;&lt;/li&gt;
      &lt;li&gt;Construct the solution in bottom-up way;&lt;/li&gt;
      &lt;li&gt;Compute its runtime complexity.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bellman-Ford Algorithm:
    &lt;ul&gt;
      &lt;li&gt;How would you apply the Bellman-Ford algorithm to find out if a graph has a negative cycle? Run 1 more round for k = V, if the distance reduced for some point, there must be a negative cycle.&lt;/li&gt;
      &lt;li&gt;Complexity: O(E * V).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D[v, 0] = INFINITY for all v != s
D[s, k] = 0 for all k
for k = 1 to V-1 do
  for each v in V do
    for each neighbor w of v do
      D[v, k] = min(D[v, k - 1], c(w, v) + D[w, k - 1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Floyd-Warshall Algorithm:
    &lt;ul&gt;
      &lt;li&gt;If the diagonal has negative numbers, then there must be a negative cycle.&lt;/li&gt;
      &lt;li&gt;How do we extract the shortest path? Every time we update D[i, j], we set P[i, j] to k. Then we recursively compute the shortest path from from i to k = P[i, j] and the path from from k = P[i, j] to j.&lt;/li&gt;
      &lt;li&gt;Complexity: O(V ^ 3)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D[i, j, 0] = c[i, j] for all i and j
for k = 1 ... V do
  for i = 1 ... V do
    for j = 1 ... V do
      D[i, j, k] = min (D[i, j, k - 1], D[i, k, k - 1] + D[k, j, k - 1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="å­¦ä¹ ç¬”è®°" /><summary type="html">è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯åº·å¥ˆå°”çš„ Algorithm Design å’Œ MIT çš„ Introduction to Algorithmsï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚</summary></entry><entry><title type="html">AI ç¬¬ä¸€éƒ¨åˆ†â€œæœç´¢â€å¤ä¹ ç¬”è®°</title><link href="/2018/09/22/AI-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%90%9C%E7%B4%A2-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="AI ç¬¬ä¸€éƒ¨åˆ†â€œæœç´¢â€å¤ä¹ ç¬”è®°" /><published>2018-09-22T21:00:00-07:00</published><updated>2018-09-22T21:00:00-07:00</updated><id>/2018/09/22/AI%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E2%80%9C%E6%90%9C%E7%B4%A2%E2%80%9D%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/09/22/AI-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%90%9C%E7%B4%A2-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯ Artificial Intelligence: A Modern Approachï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚&lt;/p&gt;

&lt;h4 id=&quot;lecture-1&quot;&gt;Lecture 1&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Agents are systems that perceive and act in some environment, including humans, robots, softbots, thermostats, etc.&lt;/li&gt;
  &lt;li&gt;Environment is world in which agent operates.&lt;/li&gt;
  &lt;li&gt;Cognitive Cycle: Perception, Memory Access, Decision, Learning, Action.&lt;/li&gt;
  &lt;li&gt;The agent function is a mathematical relationship that maps percept sequences to actions in the environment.&lt;/li&gt;
  &lt;li&gt;The agent function is computed by an agent program; the agent program runs on the physical architecture to implement the function.&lt;/li&gt;
  &lt;li&gt;A rational agent chooses whichever action maximizes the expected value of the performance measure given the percept sequence to date and the prior environment knowledge.&lt;/li&gt;
  &lt;li&gt;PEAS description of the task environment:
    &lt;ul&gt;
      &lt;li&gt;Performance: Measure for success/progress/quality;&lt;/li&gt;
      &lt;li&gt;Environment: The world in which the agent operates;&lt;/li&gt;
      &lt;li&gt;Actuators: How the agent affects the environment;&lt;/li&gt;
      &lt;li&gt;Sensors: How the agent perceives the environment.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Environment Types: fully vs. partially observable; deterministic vs. stochastic; episodic vs. sequential; static vs. dynamic; discrete vs. continuous; single vs. multi-agent.&lt;/li&gt;
  &lt;li&gt;Four basic kinds of agent programs:
    &lt;ul&gt;
      &lt;li&gt;Simple reflex agents: Select action on the basis of only the current percept;&lt;/li&gt;
      &lt;li&gt;Model-based reflex agents: To tackle partially observable environments; maintain internal state representing best estimate of current world situation; over time update state using world knowledge;&lt;/li&gt;
      &lt;li&gt;Goal-based agents: Goals describe what agent wants; by changing goals, can change what agent does in same situation;&lt;/li&gt;
      &lt;li&gt;Utility-based agents: Some solutions may be â€œbetterâ€ â€“ have higher utility; utility function maps a (sequence of) state(s) onto a real number which can help in optimization or in arbitration among goals or solutions;&lt;/li&gt;
      &lt;li&gt;All can be turned into learning agents; And a more complex variation is Hybrid agents.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-2-4&quot;&gt;Lecture 2-4&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Blind/uninformed search; heuristic/informed search&lt;/li&gt;
  &lt;li&gt;Uninformed search stratigies:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Â &lt;/th&gt;
      &lt;th&gt;BFS&lt;/th&gt;
      &lt;th&gt;Uniform Cost&lt;/th&gt;
      &lt;th&gt;DFS&lt;/th&gt;
      &lt;th&gt;Depth limited&lt;/th&gt;
      &lt;th&gt;Iterative deepening&lt;/th&gt;
      &lt;th&gt;Bidirectional&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Complete?&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Optimal?&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Time&lt;/td&gt;
      &lt;td&gt;b^d&lt;/td&gt;
      &lt;td&gt;b^(1 + C* / Îµ)&lt;/td&gt;
      &lt;td&gt;b^m&lt;/td&gt;
      &lt;td&gt;b^l&lt;/td&gt;
      &lt;td&gt;b^d&lt;/td&gt;
      &lt;td&gt;b^(d / 2)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space&lt;/td&gt;
      &lt;td&gt;b^d&lt;/td&gt;
      &lt;td&gt;b^(1 + C* / Îµ)&lt;/td&gt;
      &lt;td&gt;b * m&lt;/td&gt;
      &lt;td&gt;b * l&lt;/td&gt;
      &lt;td&gt;b * d&lt;/td&gt;
      &lt;td&gt;b^(d / 2)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;Why do people have a hard time solving missionaries and cannibals? There are a number of constraints on solutions to this problem, for example, the boat only holds one or two people, you can never have more cannibals than missionaries on either side of the river, etc. Constraints are generally thought of as making it harder to solve a problem.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-5&quot;&gt;Lecture 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Informed search stratigies:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Â &lt;/th&gt;
      &lt;th&gt;BestFS&lt;/th&gt;
      &lt;th&gt;A*&lt;/th&gt;
      &lt;th&gt;RBFS&lt;/th&gt;
      &lt;th&gt;((S)MA*)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Complete?&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y (same as A*)&lt;/td&gt;
      &lt;td&gt;Y (if solution is reachable)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Optimal?&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;Y (if admissible (Tree Search) or consistent (Graph Search))&lt;/td&gt;
      &lt;td&gt;Y (same as A*)&lt;/td&gt;
      &lt;td&gt;Y (if solution is reachable)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Time&lt;/td&gt;
      &lt;td&gt;b^m&lt;/td&gt;
      &lt;td&gt;A* expands all nodes with f(n) &amp;lt; C* (C* is cost of optimal path); some nodes with f(n) = C&lt;em&gt;; no nodes with f(n) &amp;gt; C&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;hard&lt;/td&gt;
      &lt;td&gt;Â &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space&lt;/td&gt;
      &lt;td&gt;b^m&lt;/td&gt;
      &lt;td&gt;Exponential&lt;/td&gt;
      &lt;td&gt;b * d&lt;/td&gt;
      &lt;td&gt;constant&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;A heuristic is admissible if it never overestimates the cost to reach the goal.&lt;/li&gt;
  &lt;li&gt;A heuristic is consistent if for every node n and every successor nâ€™ of n generated by any action: h(n) â‰¤ c(n, a, nâ€™) + h(nâ€™). A consistent heuristic is also admissible. It is rare for an admissible heuristic to be inconsistent.&lt;/li&gt;
  &lt;li&gt;Memory-Bounded Heuristic Search:
    &lt;ul&gt;
      &lt;li&gt;Iterative-deepening A* (IDA*): Cutoff information is the f-cost (g + h) instead of depth;&lt;/li&gt;
      &lt;li&gt;Recursive best-first search (RBFS): Search depth-first, only keep current path and branches from it in memory (saves memory over keeping entire level); Keep track of f value (f-limit) of best sibling of path currently exploring; a bit more efficient than IDA*;&lt;/li&gt;
      &lt;li&gt;(Simple) Memory-bounded A* ((S)MA*): Drop the worst-leaf node when memory is full.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Branching factor â†’ 1 â‡’ heuristic quality â†‘.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-6&quot;&gt;Lecture 6&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The success of hill climbing depends very much on the shape of the state-space land-scape: if there are few local maxima and plateaux, random-restart hill climbing will find a good solution very quickly. NP-hard problems typically have an exponential number of local maxima to get stuck on. Despite this, a reasonably good local maximum can often be found after a small number of restarts.&lt;/li&gt;
  &lt;li&gt;Local beam search: Start with k randomly generated nodes; generate all successors of each of the k; keep the best k out of the them; repeat till goal or stop condition reached.&lt;/li&gt;
  &lt;li&gt;Simulated annealing: T â†“ â‡’ e^(â–³E / T) â†’ -âˆ â‡’ Probability of bad moves â†“&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-7&quot;&gt;Lecture 7&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;checkers/draughts: like chess; scrabble: like poker.&lt;/li&gt;
  &lt;li&gt;Minimax: Complete? Y; Optimal? Y; Time? O(b^m); Space? O(b * m) or O(m).&lt;/li&gt;
  &lt;li&gt;With â€œperfect orderingâ€, the alpha-beta pruning can reduce time complexity to O(b^(m/2)).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-8&quot;&gt;Lecture 8&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Methods for imporving backtracking efficiency in CSP:
    &lt;ul&gt;
      &lt;li&gt;Most constrained variable (minimum remaining values (MRV) heuristic): Choose the variable with the fewest legal values;&lt;/li&gt;
      &lt;li&gt;Most constraining variable: Choose the variable with the most constraints on remaining variables;&lt;/li&gt;
      &lt;li&gt;Least constraining value: Given a variable, choose the one that rules out the fewest values in the remaining variables.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Forward checking: Keep track of remaining legal values for unassigned variables; terminate search when any variable has no legal values.&lt;/li&gt;
  &lt;li&gt;Arc consistency: Simplest form of propagation makes each arc consistent: X â†’ Y is consistent iff for every value x of X there is some allowed y. Time complexity: O(n^2 * d^3) (n variables, d values), each arc can be queued only d times, n^2 arcs (at most), checking one arc is O(d^2).&lt;/li&gt;
  &lt;li&gt;Iterative min-conflicts is often surprisingly effective in solving CSP.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="å­¦ä¹ ç¬”è®°" /><summary type="html">è¿™é—¨è¯¾ç¨‹æ‰€ä½¿ç”¨çš„æ•™ææ˜¯ Artificial Intelligence: A Modern Approachï¼Œæœ¬ä»½ç¬”è®°ç›´æ¥æ²¿ç”¨ä¹¦æœ¬ä¸­å¯¹å˜é‡åŠåè¯çš„å®šä¹‰ï¼Œåœ¨æ­¤æ²¡æœ‰å¯¹å®ƒä»¬è¿›è¡Œç‰¹æ®Šè§£é‡Šã€‚</summary></entry><entry><title type="html">ã€Šä¸‰ä½“ã€‹ä¹¦è¯„</title><link href="/2018/08/17/%E4%B8%89%E4%BD%93-%E4%B9%A6%E8%AF%84.html" rel="alternate" type="text/html" title="ã€Šä¸‰ä½“ã€‹ä¹¦è¯„" /><published>2018-08-17T21:00:00-07:00</published><updated>2018-08-17T21:00:00-07:00</updated><id>/2018/08/17/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E4%B9%A6%E8%AF%84</id><content type="html" xml:base="/2018/08/17/%E4%B8%89%E4%BD%93-%E4%B9%A6%E8%AF%84.html">&lt;p&gt;å†…å®¹ï¼šâ˜…â˜…â˜…â˜…â˜…&lt;/p&gt;

&lt;p&gt;æ–‡ç¬”ï¼šâ˜…â˜…â˜…â˜…â˜†&lt;/p&gt;

&lt;p&gt;æ’ç‰ˆï¼šâ˜…â˜…â˜…â˜…â˜…&lt;/p&gt;

&lt;p&gt;ç»¼åˆï¼šâ˜…â˜…â˜…â˜…â˜…&lt;/p&gt;

&lt;p&gt;ä½œä¸ºä¸€åå·¥ç§‘ç”Ÿï¼Œæˆ‘åœ¨æ–‡å­¦æ–¹é¢å¹¶æ²¡æœ‰å¤šå¤§çš„é€ è¯£ï¼Œæœ¬æ–‡åªç®€å•è°ˆè°ˆè‡ªå·±ä¸€äº›ç‰‡é¢çš„è§‚åæ„Ÿï¼Œå¦‚æœ‰è°¬è¯¯ï¼Œæ¬¢è¿æŒ‡æ­£ã€‚&lt;/p&gt;

&lt;p&gt;ã€Šä¸‰ä½“ã€‹æœ€ä»¤æˆ‘éœ‡æƒŠçš„æ˜¯å…¶åˆç†æ€§ï¼Œå®ƒä¸åƒæ˜¯ä¸€æœ¬ç§‘å¹»å°è¯´ï¼Œè€Œæ˜¯ä¸€æœ¬åƒä¸‡å¹´åæœªæ¥æ–‡æ˜çš„å†å²æ•™ç§‘ä¹¦ã€‚ç§‘å¹»ä½œå“è¦åšåˆ°è¿™ä¸€ç‚¹å¹¶ä¸å®¹æ˜“ï¼Œå…¶ä½œè€…éœ€è¦å…¼å…·è¿‡ç¡¬ç§‘å­¦ç´ è´¨å’Œæå¥½çš„æ–‡å­¦ä¿®å…»ï¼Œè€Œå¤§åˆ˜åšåˆ°äº†è¿™ä¸€ç‚¹ã€‚ã€Šä¸‰ä½“ã€‹ä»â€œè¿‘ä»£â€è®²èµ·ï¼Œä¸€æ­¥ä¸€æ­¥èµ°å‘æ·±ç©ºï¼Œä¸€æ­¥ä¸€æ­¥èµ°å‘æœªæ¥ã€‚åœ¨ã€Šä¸‰ä½“ Iã€‹ä¸­äººç±»äº†è§£åˆ°äº†å¤–æ˜Ÿæ–‡æ˜çš„å­˜åœ¨ï¼Œå¹¶è¯•å›¾ä¸å®ƒä»¬å»ºç«‹è”ç³»ï¼Œé€å±‚æ­å¼€ä¸‰ä½“äººçš„ç¥ç§˜é¢çº±ï¼›ã€Šä¸‰ä½“ IIÂ·é»‘æš—æ£®æ—ã€‹ä¸­ç½—è¾‘ä¸é›•åˆ»åœ¨è´¨å­ä¸Šçš„å¾®å‹è®¡ç®—æœºâ€œæ™ºå­â€æ–—æ™ºæ–—å‹‡ï¼Œå¹¶æ‚Ÿå‡ºäº†â€œé»‘æš—æ£®æ—æ³•åˆ™â€ï¼›åœ¨ã€Šä¸‰ä½“ IIIÂ·æ­»ç¥æ°¸ç”Ÿã€‹ä¸­äººç±»å—åˆ°äº†ç­ä¸–çš„æ‰“å‡»ï¼Œå¤ªé˜³ç³»è¢«æ¨å¾€äºŒç»´ï¼Œç¨‹å¿ƒä¸æ®‹å­˜çš„äººç±»çªç ´å…‰é€Ÿï¼Œé£å¾€æ·±ç©ºï¼Œé€æ­¥è®¤è¯†åˆ°å®‡å®™çš„ç»ˆæç§˜å¯†â€¦â€¦&lt;/p&gt;

&lt;p&gt;è¿™æ ·ä¸€ä¸ªå®å¤§çš„ä¸–ç•Œè§‚ä¸­å……æ»¡äº†ä¸¥è°¨çš„é€»è¾‘ï¼Œä¹¦ä¸­ä¸æ–­æŠ›å‡ºä¸€ä¸ªä¸ªå›°éš¾çš„é—®é¢˜ï¼Œå¤§åˆ˜ç»™å‡ºçš„è§£å†³æ–¹æ¡ˆè®©ä½ ä¸€æ¬¡æ¬¡è±ç„¶å¼€æœ—ï¼šé¢å£è€…ä»¬åº”è¯¥å¦‚ä½•èº²é¿æ™ºå­çš„ç›‘æ§ï¼Œå‡­ä¸€å·±ä¹‹åŠ›å¯¹æŠ—ä¸è‡ªå·±å®åŠ›æ‚¬æ®Šçš„ä¸‰ä½“æ–‡æ˜ï¼Ÿåœ¨é»‘æš—æ£®æ—æ³•åˆ™ä¸‹ä¸‰ä½“äººæš—ç¤ºçš„å®‰å…¨å£°æ˜ç©¶ç«Ÿæ˜¯ä»€ä¹ˆï¼Ÿäº‘å¤©æ˜çš„ç«¥è¯ä¸­æš—ç¤ºçš„ç§‘æŠ€ä¿¡æ¯åˆæ˜¯ä»€ä¹ˆï¼Ÿä¹¦ä¸­ç»™å‡ºçš„ç­”æ¡ˆç²¾å¦™æ— æ¯”ï¼Œè®©ä½ ä¸æ–­æ‹æ‰‹ç§°å¿«ã€‚è¿™ç§æ„Ÿå—å¾ˆæ¥è¿‘ä½ å¯¹ä¸€é“æ•°å­¦é¢˜è‹¦æ€å†¥æƒ³å¾ˆä¹…åï¼Œç¿»é˜…ç­”æ¡ˆæ—¶çš„é‚£ç§é¡¿æ‚Ÿæ„Ÿã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘åœ¨â€œæ–‡ç¬”â€è¿™ä¸€é¡¹ç»™å‡ºçš„å››æ˜Ÿå¹¶ä¸ä»£è¡¨å¤§åˆ˜çš„æ–‡å­¦ç´ è´¨ä¸å¤Ÿå¥½ï¼Œç›¸åï¼Œæˆ‘è¿™æ ·çš„å·¥ç§‘ç”Ÿéš¾ä»¥æœ›å…¶é¡¹èƒŒã€‚å››æ˜Ÿåªæ˜¯ä¸ºäº†å’Œã€Šè¯¸è‘›äº®ä¼ ã€‹é‚£æ ·æè‡´ä¼˜ç¾çš„æ–‡ç¬”åŠ ä»¥åŒºåˆ†ï¼Œã€Šä¸‰ä½“ã€‹ä¸­å­˜åœ¨æå°‘æ•°çš„è¯­è¨€ä¸è§„èŒƒå¹¶ä¸å½±å“å®ƒçš„ä¼Ÿå¤§ã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘éå¸¸æ¨èæ‰€æœ‰ç†å·¥ç§‘çš„åŒå­¦ä»¬éƒ½é˜…è¯»ä¸€ä¸‹ã€Šä¸‰ä½“ã€‹ï¼Œå®ƒç»™ä½ å¸¦æ¥çš„éœ‡æ’¼éš¾ä»¥ç”¨è¨€è¯­å½¢å®¹ï¼Œåªæœ‰è‡ªå·±è¯»è¿‡ä¹‹åæ‰èƒ½çœŸåˆ‡æ„Ÿå—ã€‚&lt;/p&gt;</content><author><name></name></author><category term="é˜…è¯»" /><summary type="html">å†…å®¹ï¼šâ˜…â˜…â˜…â˜…â˜…</summary></entry><entry><title type="html">ã€Šå¤§è°‹å°è®¡äº”åå¹´ï¼šè¯¸è‘›äº®ä¼  ç¬¬ä¸€å·ã€‹ä¹¦è¯„</title><link href="/2018/05/24/%E5%A4%A7%E8%B0%8B%E5%B0%8F%E8%AE%A1%E4%BA%94%E5%8D%81%E5%B9%B4-%E8%AF%B8%E8%91%9B%E4%BA%AE%E4%BC%A0-%E7%AC%AC%E4%B8%80%E5%8D%B7-%E4%B9%A6%E8%AF%84.html" rel="alternate" type="text/html" title="ã€Šå¤§è°‹å°è®¡äº”åå¹´ï¼šè¯¸è‘›äº®ä¼  ç¬¬ä¸€å·ã€‹ä¹¦è¯„" /><published>2018-05-24T21:00:00-07:00</published><updated>2018-05-24T21:00:00-07:00</updated><id>/2018/05/24/%E3%80%8A%E5%A4%A7%E8%B0%8B%E5%B0%8F%E8%AE%A1%E4%BA%94%E5%8D%81%E5%B9%B4:%E8%AF%B8%E8%91%9B%E4%BA%AE%E4%BC%A0%20%E7%AC%AC%E4%B8%80%E5%8D%B7%E3%80%8B%E4%B9%A6%E8%AF%84</id><content type="html" xml:base="/2018/05/24/%E5%A4%A7%E8%B0%8B%E5%B0%8F%E8%AE%A1%E4%BA%94%E5%8D%81%E5%B9%B4-%E8%AF%B8%E8%91%9B%E4%BA%AE%E4%BC%A0-%E7%AC%AC%E4%B8%80%E5%8D%B7-%E4%B9%A6%E8%AF%84.html">&lt;p&gt;å†…å®¹ï¼šâ˜…â˜…â˜…â˜…â˜†&lt;/p&gt;

&lt;p&gt;æ–‡ç¬”ï¼šâ˜…â˜…â˜…â˜…â˜…&lt;/p&gt;

&lt;p&gt;æ’ç‰ˆï¼šâ˜…â˜…â˜…â˜…â˜…&lt;/p&gt;

&lt;p&gt;ç»¼åˆï¼šâ˜…â˜…â˜…â˜…â˜…&lt;/p&gt;

&lt;p&gt;ä½œä¸ºä¸€åå·¥ç§‘ç”Ÿï¼Œæˆ‘åœ¨æ–‡å­¦æ–¹é¢å¹¶æ²¡æœ‰å¤šå¤§çš„é€ è¯£ï¼Œæœ¬æ–‡åªç®€å•è°ˆè°ˆè‡ªå·±ä¸€äº›ç‰‡é¢çš„è§‚åæ„Ÿï¼Œå¦‚æœ‰è°¬è¯¯ï¼Œæ¬¢è¿æŒ‡æ­£ã€‚&lt;/p&gt;

&lt;p&gt;æ­£å¦‚é©¬ä¼¯åº¸åœ¨æœ¬ä¹¦åºè¨€ä¸­æ‰€è¿°ï¼Œä½œè€…è‹¥è™šè‘—æ­¤ä¹¦çš„ç›®çš„æ˜¯æ´—å»è¯¸è‘›äº®è„¸ä¸Šçš„æ²¹å½©ã€‚äººä»¬ç†ŸçŸ¥çš„ã€Šä¸‰å›½æ¼”ä¹‰ã€‹ä¸­æœ‰å¤ªå¤šè¯¸è‘›äº®çš„æµ®å¤¸æ•…äº‹ï¼Œå› æ­¤è‹¥è™šå¸Œæœ›èƒ½è¿˜åŸå‡ºä¸€ä¸ªâ€œæœ‰è¡€æœ‰è‚‰ã€çœŸæƒ…å®æ„Ÿâ€çš„è¯¸è‘›äº®ã€‚ä½œè€…ç¡®å®åšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œè‹¥è™šåœ¨ç ”è¯»å¤§é‡å²å®ä¹‹ååœ¨æ­¤åŸºç¡€ä¸Šè¿›è¡ŒçŒœæƒ³ï¼Œç»†èŠ‚ä¸°å¯Œåœ°æè¿°äº†è¯¸è‘›äº®ä»å‡ å²åˆ°äºŒåå‡ å²è¿™ä¸€æ—¶é—´é˜¶æ®µçš„ç”Ÿæ´»ç»å†ï¼Œå¦‚æœå°†å†å²æ–‡çŒ®ä¸­çš„è¯¸è‘›äº®æ¯”ä½œåƒç´ å›¾ï¼Œé‚£ä¹ˆè¿™æœ¬ä¹¦ä¸­çš„è¯¸è‘›äº®å°±å¦‚ AR ç«‹ä½“æ¨¡å‹ä¸€èˆ¬çœŸå®ã€‚&lt;/p&gt;

&lt;p&gt;ä½œè€…å¯¹æ–‡å­—çš„é©¾é©­èƒ½åŠ›å ªç§°ä¸€æµã€‚ä¹¦ä¸­è¯¸è‘›äº®å’Œåˆ˜å¤‡è¿™ä¸¤æ¡ä¸»çº¿åŒæ—¶æ¨è¿›ï¼Œèµ·åˆå®ƒä»¬åƒä¸¤æ¡å¹³è¡Œçº¿ï¼Œä½†æ¸æ¸åœ°å®ƒä»¬æœ‰äº†å¤¹è§’ï¼Œä¼¼ä¹ä¼šåœ¨ä¸ä¹…çš„å°†æ¥ç›¸ä¼šã€‚ä½œè€…å–„ä»¥æ™¯è¡¬æƒ…ï¼Œå¯¹è‡ªç„¶äº‹ç‰©çš„æå†™ä¿¡æ‰‹æ‹ˆæ¥ï¼Œè®©è¯»è€…çœ¼ä¸­æœ‰ç”»ï¼Œä¹Ÿèƒ½çœŸåˆ‡ä½“ä¼šåˆ°äººç‰©æƒ…æ„Ÿã€‚ä½œè€…è¿˜ä¼šæ—¶ä¸æ—¶æ‘˜æ¥ä¸€ä¸¤å¥å¼•ç”¨ï¼Œæˆ–æ˜¯èµ‹ä¸€ä¸¤é¦–è¯—æ­Œï¼Œè®©è¯»è€…å—…åˆ°ä¹¦é¦™ã€‚æœ€ä»¤æˆ‘æƒŠå¹çš„æ˜¯ä¹¦ä¸­å¯¹è¯¸è‘›äº®å‡ æ¬¡è¾©è¿°çš„æå†™ï¼Œè¯¸è‘›äº®é€šè¿‡è¨€è¯­è¾©å€’å¯¹æ‰‹æ—¶ï¼Œä½œè€…ä¹Ÿéœ€è¾©å€’è¯»è€…ï¼Œè¯¸è‘›äº®æœ‰ç†æœ‰æ®åœ°è¯æ˜ç€è‡ªå·±è®ºç‚¹æ—¶ï¼Œä¹Ÿæ˜¯ä½“ç°ç€æœ¬ä¹¦ä½œè€…å¯¹è¿™äº›é—®é¢˜çš„æ·±åˆ»æ€è€ƒã€‚&lt;/p&gt;

&lt;p&gt;åœ¨æˆ‘çœ‹æ¥ï¼Œå·ä¸€ç¾ä¸­ä¸è¶³çš„æ˜¯ä½œè€…å¹¶æ²¡èƒ½â€œæŠ¹å»è¯¸è‘›äº®è„¸ä¸Šçš„æ²¹å½©â€ã€‚å¯èƒ½å› ä¸ºä½œè€…æœ¬èº«å¯¹è¯¸è‘›äº®çš„ç—´æƒ…ï¼Œå…¨ä¹¦å­—é‡Œè¡Œé—´å†…éƒ½é€ç€ä»–/å¥¹å¯¹è¯¸è‘›äº®çš„å–œçˆ±ã€‚é™¤åœ¨ä»–å¹´å¹¼ä¹ æ£‹æ—¶ï¼Œæœ¬ä¹¦ä¸­çš„è¯¸è‘›äº®å¯¹å¼ˆæœªå°è´¥è¿‡ä¸€åœºã€‚è¿™é‡Œçš„å¯¹å¼ˆä¸åªæŒ‡å›´æ£‹ï¼Œè¿˜æŒ‡å›´æ£‹çš„å„ç§å˜ä½“ï¼Œä»¥åŠæ°‘é—´å¤§ä¼—å–œæ¬¢çš„å„ç§åšå¼ˆæ¸¸æˆï¼›è¯¸è‘›äº®çš„å¯¹æ‰‹ä¹Ÿä¸åªæŒ‡è·¯äººç”²ä¹™ä¸™ä¸ï¼Œè¿˜åŒ…æ‹¬ä¸–é—´å„è·¯é¡¶çº§é«˜æ‰‹ã€‚ä½†å‡¡æ˜¯æ™ºåŠ›æ¯”æ‹¼ï¼Œè¯¸è‘›äº®ä¹Ÿæœªå°è´¥è¿‡ä¸€åœºï¼Œå”¯ä¸€çš„é—æ†¾æ˜¯åœ¨é˜Ÿå‹æ‹–åè…¿çš„æƒ…å†µä¸‹ä¸åºç»Ÿæˆ˜å¹³ï¼Œé™¤æ­¤ä¹‹å¤–çš„æ¯”æ‹¼è¯¸è‘›äº®å‡å…¨èƒœã€‚è‹¥è™šå»é™¤äº†â€œè‰èˆ¹å€Ÿç®­â€ã€â€œç©ºåŸè®¡â€è¿™æ ·çš„ç¥è¯ï¼Œä½†ä»–/å¥¹å´æœæ’°å‡ºäº†å¦ä¸€æ‰¹ç¥è¯ã€‚&lt;/p&gt;

&lt;p&gt;ã€Šå¤§è°‹å°è®¡äº”åå¹´ï¼šè¯¸è‘›äº®ä¼ ã€‹å…¨ä¹¦åˆ†ä¸ºäº”å·ï¼Œæˆ‘æ‰€å€Ÿé˜…çš„æ˜¯ç¬¬ä¸€å·ã€‚æœ¬å·å†…å®¹æ˜¯äººä»¬è¾ƒå°‘çŸ¥æ™“çš„è¯¸è‘›äº®å¹¼å¹´æ—¶æœŸçš„æ•…äº‹ï¼Œå¦‚æœå¤§å®¶æœ‰å…´è¶£çš„è¯ï¼Œä¸å¦¨ä¸€è¯»ã€‚&lt;/p&gt;</content><author><name></name></author><category term="é˜…è¯»" /><summary type="html">å†…å®¹ï¼šâ˜…â˜…â˜…â˜…â˜†</summary></entry><entry><title type="html">ã€Šå¤©æ‰åœ¨å·¦ ç–¯å­åœ¨å³ã€‹ä¹¦è¯„</title><link href="/2018/05/24/%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6-%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3-%E4%B9%A6%E8%AF%84.html" rel="alternate" type="text/html" title="ã€Šå¤©æ‰åœ¨å·¦ ç–¯å­åœ¨å³ã€‹ä¹¦è¯„" /><published>2018-05-24T21:00:00-07:00</published><updated>2018-05-24T21:00:00-07:00</updated><id>/2018/05/24/%E3%80%8A%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6%20%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3%E3%80%8B%E4%B9%A6%E8%AF%84</id><content type="html" xml:base="/2018/05/24/%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6-%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3-%E4%B9%A6%E8%AF%84.html">&lt;p&gt;å†…å®¹ï¼šâ˜…â˜…â˜…â˜…â˜†&lt;/p&gt;

&lt;p&gt;æ–‡ç¬”ï¼šâ˜…â˜…â˜…â˜†â˜†&lt;/p&gt;

&lt;p&gt;æ’ç‰ˆï¼šâ˜…â˜…â˜†â˜†â˜†&lt;/p&gt;

&lt;p&gt;ç»¼åˆï¼šâ˜…â˜…â˜…â˜†â˜†&lt;/p&gt;

&lt;p&gt;ä½œä¸ºä¸€åå·¥ç§‘ç”Ÿï¼Œæˆ‘åœ¨æ–‡å­¦æ–¹é¢å¹¶æ²¡æœ‰å¤šå¤§çš„é€ è¯£ï¼Œæœ¬æ–‡åªç®€å•è°ˆè°ˆè‡ªå·±ä¸€äº›ç‰‡é¢çš„è§‚åæ„Ÿï¼Œå¦‚æœ‰è°¬è¯¯ï¼Œæ¬¢è¿æŒ‡æ­£ã€‚&lt;/p&gt;

&lt;p&gt;è¿™æœ¬ä¹¦æœ€å¸å¼•äººçš„å½“å±å®ƒçš„å†…å®¹ï¼Œä½œè€…é«˜é“­è€—æ—¶æ•°å¹´ä¸æ•°ç™¾ä½ç²¾ç¥ç—…äººè¿›è¡Œæ·±å…¥äº¤è°ˆï¼ŒæœŸé—´é€šè¿‡å½•éŸ³å’Œç¬”è®°è¯¦ç»†åœ°è®°å½•äº†ä»–ä¸ç—…äººé—´çš„äº¤æµè¿‡ç¨‹ï¼Œæœ€åç»è¿‡æ•´ç†ï¼Œå®Œæˆäº†è¿™ä¸€æœ¬ä¹¦ã€‚&lt;/p&gt;

&lt;p&gt;å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™æœ¬ä¹¦å¹¶ä¸æ˜¯ä¸€ä»½å®¢è§‚çš„è®¿è°ˆæ‰‹è®°ã€‚ç…§ä½œè€…çš„åŸè¯ï¼Œæ­£æ–‡ 48 ä¸ªç¯‡ç« ä¸­ä»…â€œè¿‘20ä½™ç¯‡â€æ¥è‡ªçœŸå®æ¡ˆä¾‹ï¼Œä¸”è¿™äº›æ¡ˆä¾‹ä¹Ÿç»è¿‡â€œå¢æ·»æˆ–åˆ å‡â€ã€‚ä¹Ÿè®¸æ˜¯ä¸ºäº†è¾¾åˆ°æŸäº›è‰ºæœ¯æ•ˆæœï¼Œä½œè€…â€œç¥åŒ–â€äº†ä¸å°‘ç²¾ç¥ç—…äººã€‚æ¯”å¦‚ä¹¦ä¸­å¤šæ¬¡æåˆ°æœ‰ç—…äººä½¿ç”¨å°–ç«¯çš„é‡å­ç‰©ç†çŸ¥è¯†æ¥æ„é€ è‡ªå·±çš„ä¸–ç•Œè§‚ï¼Œæˆ‘å¾ˆæ€€ç–‘ä½œè€…åœ¨è‘—ä¹¦æ—¶æŸ¥é˜…äº†ä¸å°‘ç›¸å…³èµ„æ–™ï¼Œæ›¿é‚£äº›ç—…äººåœ†ä»–ä»¬çš„è§‚ç‚¹ï¼Œè®©é‚£äº›ç—…äººçš„ç†è®ºæ˜¾å¾—å¤©è¡£æ— ç¼ã€‚è¿™æ ·ä¸€æ¥ï¼Œä¹¦çš„å¯è¯»æ€§å’Œè¶£å‘³æ€§éƒ½ä¼šä¸Šå‡ï¼Œä½†ä¹¦ä¹Ÿä¼šå› ä¸¢å¤±äº†çœŸå®æ€§è€Œæˆä¸ºå°è¯´ã€‚å½“ç„¶ï¼Œä¹¦ä¸­çš„ä¸€äº›æ€è€ƒæ˜¯æ·±åˆ»çš„ï¼Œä½œè€…å†™ä¹¦çš„ç›®çš„ä¸åœ¨äºå°†å…¶ä½œä¸ºåŒ»å­¦æ¡ˆä¾‹ä¾›åäººåˆ†æï¼Œè€Œæ˜¯å¸Œæœ›è¯»è€…èƒ½çœ‹åˆ°æ›´å®½å¹¿çš„ä¸–ç•Œã€‚&lt;/p&gt;

&lt;p&gt;æœ¬ä¹¦åŒ…å«å¤§æ®µå¯¹ç™½ï¼Œé£è¯é€ å¥ååˆ†å£è¯­åŒ–ï¼Œå¯¹äº¤è°ˆåŒæ–¹çš„ç¥æƒ…ã€åŠ¨ä½œå’Œå¿ƒç†æ²¡æœ‰è¿‡å¤šçš„æå†™ï¼Œä¸è¿‡ä¹Ÿä¸å¥‡æ€ªï¼Œæœ¬ä¹¦æ˜¯äº‹å‘åä¸€å¹´ç”±ä½œè€…æŒ‰å½•éŸ³å’Œç¬”è®°è¿›è¡Œæ•´ç†ï¼Œç¼ºä¹ç»†èŠ‚åœ¨æ‰€éš¾å…ã€‚å¦å¤–ä½œè€…æœ¬èº«å¹¶ä¸ä¸¥è°¨ï¼Œä¹¦ä¸­å‡ºç°äº†ç±»ä¼¼â€œæŒ‰ç™¾åˆ†æ¯”æ¥è¯´ï¼ŒæŸæŸå¤§æ¦‚å ä¸‰åˆ†ä¹‹ä¸€â€è¿™æ ·çš„æªè¾ï¼Œä½œè€…å¯¹ã€Šé»‘å®¢å¸å›½ã€‹è¿™ä¸€éƒ¨ç”µå½±çš„è‹±è¯­ç§°å‘¼åœ¨ä¹¦ä¸­ä¹Ÿå‰åä¸ä¸€ã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘ä»ä¸­å±±å¤§å­¦å›¾ä¹¦é¦†ä¸­å€Ÿåˆ°äº†è¿™æœ¬ä¹¦ï¼Œå®ƒç”± 2015 å±ŠæŸæ¯•ä¸šç”Ÿæèµ ï¼Œå› æ­¤å¯èƒ½ä¸ºç›—ç‰ˆä¹¦ç±ã€‚ä¹¦ä¸­æœ‰æ•°é‡å¯è§‚çš„é”™åˆ«å­—ï¼Œå°åˆ·è´¨é‡ä¹Ÿä¸é«˜ã€‚&lt;/p&gt;

&lt;p&gt;æ€»çš„æ¥è¯´ï¼Œè¿™æ˜¯ä¸€æœ¬æœ‰æ„æ€çš„ä¹¦ã€‚&lt;/p&gt;</content><author><name></name></author><category term="é˜…è¯»" /><summary type="html">å†…å®¹ï¼šâ˜…â˜…â˜…â˜…â˜†</summary></entry><entry><title type="html">é¦™æ¸¯æ¾³é—¨ä¹‹æ—…</title><link href="/2018/05/12/%E9%A6%99%E6%B8%AF%E6%BE%B3%E9%97%A8%E4%B9%8B%E6%97%85.html" rel="alternate" type="text/html" title="é¦™æ¸¯æ¾³é—¨ä¹‹æ—…" /><published>2018-05-12T21:00:00-07:00</published><updated>2018-05-12T21:00:00-07:00</updated><id>/2018/05/12/%E9%A6%99%E6%B8%AF%E6%BE%B3%E9%97%A8%E4%B9%8B%E6%97%85</id><content type="html" xml:base="/2018/05/12/%E9%A6%99%E6%B8%AF%E6%BE%B3%E9%97%A8%E4%B9%8B%E6%97%85.html">&lt;p&gt;æœ€è¿‘å’Œ shuq3 å»äº†ä¸€è¶Ÿé¦™æ¸¯å’Œæ¾³é—¨ï¼Œè¿™äº›æ˜¯æˆ‘ä»¬åœ¨é€”ä¸­æ‹æ‘„çš„ç…§ç‰‡ã€‚&lt;/p&gt;

&lt;div id=&quot;photo-container&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;hint&quot;&gt;æ­£åœ¨åŠ è½½...åŠ è½½å®Œæˆå¤§çº¦éœ€è¦ 20M çš„æµé‡ã€‚&lt;/div&gt;

&lt;script&gt;
  times = 0;
  interval = setInterval(function() {
    times += 1;
    if (times === 87) {
      clearInterval(interval);
      $('#hint').html('åŠ è½½å®Œæˆï¼');
    }
    $('#photo-container').append('&lt;img class=&quot;photo&quot; src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Trip%20to%20HK%20%26%20MO/' + times + '.jpg&quot;/&gt;');
  }, 2000);
&lt;/script&gt;</content><author><name></name></author><category term="æ—…è¡Œ" /><summary type="html">æœ€è¿‘å’Œ shuq3 å»äº†ä¸€è¶Ÿé¦™æ¸¯å’Œæ¾³é—¨ï¼Œè¿™äº›æ˜¯æˆ‘ä»¬åœ¨é€”ä¸­æ‹æ‘„çš„ç…§ç‰‡ã€‚</summary></entry><entry><title type="html">å¦‚ä½•åœ¨ä¸åŒç½‘ç»œç¯å¢ƒä¸‹è°ƒè¯•ç½‘ç«™</title><link href="/2018/03/11/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%B0%83%E8%AF%95%E7%BD%91%E7%AB%99.html" rel="alternate" type="text/html" title="å¦‚ä½•åœ¨ä¸åŒç½‘ç»œç¯å¢ƒä¸‹è°ƒè¯•ç½‘ç«™" /><published>2018-03-11T21:00:00-07:00</published><updated>2018-03-11T21:00:00-07:00</updated><id>/2018/03/11/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%B0%83%E8%AF%95%E7%BD%91%E7%AB%99</id><content type="html" xml:base="/2018/03/11/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%B0%83%E8%AF%95%E7%BD%91%E7%AB%99.html">&lt;p&gt;å¾ˆå¤šäººéƒ½çŸ¥é“ Chrome å¼€å‘è€…å·¥å…·çš„ Network ä¸‹å¯ä»¥è‡ªå®šä¹‰ç½‘ç»œç¯å¢ƒï¼ŒChrome å¯ä»¥æ¨¡æ‹Ÿåœ¨ Fast 3Gã€Slow 3G ç­‰ä¸€ç³»åˆ—ç½‘ç»œç¯å¢ƒä¸­åŠ è½½é¡µé¢ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Fiddler%20%26%20Clumsy/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;å¦‚æœä½ åªæ˜¯æƒ³ç®€å•åœ°è°ƒè¯•è°ƒè¯•æœ¬åœ°ç½‘ç«™ï¼Œé‚£ä¹ˆè¿™ä¸ªå·¥å…·å¯ä»¥æ»¡è¶³ä½ çš„éœ€æ±‚ã€‚ä½†æ˜¯ä½¿ç”¨è¿™ç§æ–¹æ³•åªèƒ½â€œæ”¾æ…¢â€ç½‘ç»œï¼Œå¦‚æœä½ æœ¬èº«çš„ç½‘ç»œç¯å¢ƒå°±å¾ˆç³Ÿç³•ï¼ŒåŠ è½½ç½‘ç«™çš„æ—¶é—´å¾ˆé•¿ï¼Œæˆ–è€…ä½ éœ€è¦æ›´åŠ é«˜çº§çš„ç½‘ç»œè®¾ç½®ï¼Œæ¯”å¦‚è®¾ç½®ä¸¢åŒ…ç‡ï¼Œå‹ä½å¸¦å®½å€¼ï¼Œé‚£ä¹ˆè¿™ä¸ªå·¥å…·å¹¶ä¸èƒ½æ»¡è¶³ä½ çš„éœ€æ±‚ã€‚è¿™ç¯‡æ–‡ç« å¸Œæœ›è§£å†³çš„é—®é¢˜æ˜¯å°†ç½‘ç»œç¯å¢ƒå¯æ§åŒ–ï¼ŒåŸºæœ¬çš„è®¾æƒ³æ˜¯ï¼Œå°†å¤–éƒ¨ç½‘ç«™ç¼“å­˜åœ¨ä¸å—ç½‘ç»œç¯å¢ƒå¹²æ‰°çš„å†…ç½‘ï¼Œç„¶åäººå·¥åœ°åˆ¶é€ æ—¶å»¶ã€ä¸¢åŒ…ã€å¸¦å®½é™åˆ¶ç­‰å› ç´ ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Fiddler%20%26%20Clumsy/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ä»£ç†æœåŠ¡å™¨&quot;&gt;ä»£ç†æœåŠ¡å™¨&lt;/h4&gt;

&lt;p&gt;åœ¨ä»£ç†æœåŠ¡å™¨ä¸Šæˆ‘ä»¬éœ€è¦ç”¨åˆ° Web è°ƒè¯•å·¥å…· Fiddlerã€‚å®ƒæœ¬èº«çš„åŠŸèƒ½æœ‰å¾ˆå¤šï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°çš„æ˜¯å®ƒçš„ç›‘å¬åŠŸèƒ½å’Œ AutoResponderã€‚Fiddler å¯ä»¥ç›‘å¬å½“å‰æœºå™¨ä¸Šå‘å‡ºçš„ HTTP è¯·æ±‚åŠæ”¶åˆ°çš„ HTTP å“åº”ï¼Œå¹¶å¯ä»¥æŒ‰ç…§è¿›ç¨‹ ID å¯¹æ•è·åˆ°çš„æ•°æ®è¿›è¡Œè¿‡æ»¤ã€‚AutoResponder å¯ä»¥ä½¿ç”¨æ•è·åˆ°çš„æ•°æ®æ¨¡æ‹Ÿ Web æœåŠ¡å™¨å¯¹å®¢æˆ·ç«¯ä½œå‡ºå“åº”ã€‚&lt;/p&gt;

&lt;p&gt;é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä»£ç†æœåŠ¡å™¨ä¸Šçš„æµè§ˆå™¨è®¿é—®æˆ‘ä»¬éœ€è¦è°ƒè¯•çš„ç½‘ç«™ï¼Œåœ¨æ­¤æœŸé—´ä½¿ç”¨ Fiddler æ•è·æ‰€æœ‰è¿›å‡ºçš„ HTTP æ•°æ®åŒ…ï¼Œå°†å®ƒä»¬ç¼“å­˜åœ¨æœ¬åœ°ã€‚ç„¶åï¼Œæˆ‘ä»¬æ‰“å¼€ AutoResponderï¼Œå®ƒå°†ä½¿ç”¨å…ˆå‰ç¼“å­˜çš„ HTTP å“åº”å›å¤å‘å¾€æœ¬æœº 8888 ç«¯å£çš„ HTTP è¯·æ±‚ã€‚æœ€åï¼Œæˆ‘ä»¬è¿˜éœ€è¦è®¾ç½® Clumsy æ¥åˆ¶é€ æˆ‘ä»¬æ‰€éœ€çš„ç½‘ç»œç¯å¢ƒã€‚&lt;/p&gt;

&lt;p&gt;ä¸‹å›¾ä¸º AutoResponder ä»£ç† http://www.qq.comï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Fiddler%20%26%20Clumsy/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ä¸‹å›¾ä¸ºä½¿ç”¨ Clumsy åœ¨ 8888 ç«¯å£ä¸Šåˆ¶é€ æˆ‘ä»¬æ‰€éœ€çš„ç½‘ç»œç¯å¢ƒï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Fiddler%20%26%20Clumsy/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;è®¿é—®æ–¹&quot;&gt;è®¿é—®æ–¹&lt;/h4&gt;

&lt;p&gt;æˆ‘ä»¬åªéœ€è¦è®¾ç½®æµè§ˆå™¨ä»£ç†ï¼Œè®©å®ƒå°†æ‰€æœ‰ HTTP è¯·æ±‚éƒ½å‘å¾€ ä»£ç†æœåŠ¡å™¨IP:8888 å³å¯ï¼Œæ¯”å¦‚ Chrome æµè§ˆå™¨å¯ä»¥ä½¿ç”¨æ’ä»¶ SwitchyOmegaã€‚è‡³æ­¤ï¼Œæˆ‘ä»¬éœ€è¦è°ƒè¯•çš„ç½‘ç«™æ‰€å¤„ç½‘ç»œç¯å¢ƒå°±æ˜¯å®Œå…¨å¯æ§çš„äº†ã€‚&lt;/p&gt;</content><author><name></name></author><category term="ç½‘ç»œ" /><summary type="html">å¾ˆå¤šäººéƒ½çŸ¥é“ Chrome å¼€å‘è€…å·¥å…·çš„ Network ä¸‹å¯ä»¥è‡ªå®šä¹‰ç½‘ç»œç¯å¢ƒï¼ŒChrome å¯ä»¥æ¨¡æ‹Ÿåœ¨ Fast 3Gã€Slow 3G ç­‰ä¸€ç³»åˆ—ç½‘ç»œç¯å¢ƒä¸­åŠ è½½é¡µé¢ï¼š</summary></entry></feed>
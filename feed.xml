<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-09-20T10:38:53-07:00</updated><id>/</id><title type="html">Random Thoughts</title><subtitle>©️ Designed by shuq3 &amp; An0nym6</subtitle><entry><title type="html">LeetCode 刷题总结 1-50</title><link href="/2019/09/16/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93-1-50.html" rel="alternate" type="text/html" title="LeetCode 刷题总结 1-50" /><published>2019-09-16T21:00:00-07:00</published><updated>2019-09-16T21:00:00-07:00</updated><id>/2019/09/16/LeetCode%20%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%201-50</id><content type="html" xml:base="/2019/09/16/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93-1-50.html">&lt;p&gt;为了找工作，题还是要刷起来~&lt;/p&gt;

&lt;h4 id=&quot;problem-4&quot;&gt;Problem 4&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 我们很容易想到需要使用二分来完成这道题，但它的输入却是两个数组，这使普通的二分对此题无效。解这道题的关键在于意识到如果数组 1 的 break point i 确定了，那么数组 2 的 break point j 也确定了，因为我们需要维持中位数两端数字个数一致，因此我们只需要对 i 进行二分即可。这道题即使想到这里可能也需要一些时间才能写出，实现时我们需要对奇偶等一些细节进行探讨。&lt;/p&gt;

&lt;h5 id=&quot;problem-5&quot;&gt;Problem 5&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 看到这道题的直观想法是生成一个倒序字符串，然后使用动规找出最长公共子串，但是这样做需要考虑一种情况：acxyzca，它的“ac”和“ca”会被匹配到一起；另一种做法是直接动规，从一个点开始往两端寻找。但是这道题最快的解法其实是最简单的解法，那就是遍历字符串的每一个字符，同时往两端查找，虽然这种做法和动规同样是 O(n^2) 的最坏复杂度，但是考虑到多数情况下字符串都不对称，因此它的实际复杂度应该接近于 O(n)。我相信这道题应该还有更快的解法，但是刚刚提到的解法已经可以过这道题的要求了。&lt;/p&gt;

&lt;h5 id=&quot;problem-11&quot;&gt;Problem 11&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 我们显然不能使用暴力 O(n^2) 来解这道题，凭直觉来看也不大可能是任何带 log 的复杂度，因此我们只能硬着头皮使用 O(n) 复杂度的算法：贪心。想出贪心算法非常简单，贪心的难点永远在于对它正确性的证明。&lt;/p&gt;

&lt;p&gt;这道题我们使用的贪心算法是：起初将左边界和右边界分别安放在最两端，然后我们将较矮的那个边界向中心收，以此循环，直到左右边界相碰，最优解一定存在于这个过程的某个状态中。我们需要通过反证法来证明这个算法的正确性：假设某一时刻左边界为 i，右边界为 j，我们假设左边界较矮，因此我们需要进行 i++。算法的反面是，存在一个最优解，它的左边界就是 i，右边界是小于 j 的某一个值，而我们 i++ 时把它错过了。我们很容易证明这个反面的错误性，因为任何以 i 为左边界，右边界小于 j 的容器体积都不可能有容器 (i, j) 大，从而我们证明了贪心算法的正确性。&lt;/p&gt;

&lt;h5 id=&quot;problem-16&quot;&gt;Problem 16&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-closest/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 这道题的解法其实很直观，暴力的话我们需要三重循环，但是其实这里有一个非常简单有效的优化，我们可以把首尾合到一个循环里，这样我们就可以使用 O(n^2) 的复杂度来解出这道题了。&lt;/p&gt;

&lt;h5 id=&quot;problem-31&quot;&gt;Problem 31&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/next-permutation/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 先举一个例子：126543，它的下一个排列数是 132456。通过这个例子我们便已经可以得出算法了：倒序搜索这个数，找到第一个下降的点 2，颠倒它之后的所有数字 123456，再交换它与它之后的那个数字即可。&lt;/p&gt;

&lt;h5 id=&quot;problem-32&quot;&gt;Problem 32&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-valid-parentheses/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 直接给出一维动规的解法，这个答案有点巧妙：假设我们已经找到了当字符串长度为 n - 1 时的最长合理括号，那么如果第 n 位是“(”，答案保持不变；如果第 n 位是“)”，那么答案分两种情况：1. 如果第 n - 1 位是“(”，那么答案为上一步的答案加 2；2. 如果第 n - 1 位是“)”，上一步的答案为 a，那么答案为上一步的答案加 2 加上追踪到 a + 1 步前的答案。&lt;/p&gt;

&lt;p&gt;一个简单的例子是：()((()))，前 7 步的答案是 ans = [0, 2, 2, 2, 2, 2, 4]，那么第 8 步的答案为 ans[7] + 2 + ans[7 - ans[7] - 1] = 4 + 2 + ans[2] = 8。&lt;/p&gt;

&lt;h5 id=&quot;problem-37&quot;&gt;Problem 37&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sudoku-solver/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 不用多想，DFS 是效率最高的解。&lt;/p&gt;

&lt;h5 id=&quot;problem-41&quot;&gt;Problem 41&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/first-missing-positive/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 这道题很有意思，我们需要意识到一个问题，如果数组长度是 n 的话，那么我们需要找的那个丢掉的数一定是小于 n 的。根据这个思路我们就可以得出解决了，我们只需要遍历一下这个数组，如果扫描到数字 x，那么我们就把它放在第 x 位，如果 x 超出了 n，那么我们直接不管它即可；接着我们再扫描一次数组，找出数字不等于位置的第一个数，那个位置就是我们需要找的第一个丢失的整数。&lt;/p&gt;

&lt;h5 id=&quot;problem-42&quot;&gt;Problem 42&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 首先说这题的暴力思路：遍历每一个位置，往左往右找到边界，该位置的水的体积就是左右边界中的小值，这样的复杂度时 O(n^2)。优化它的思路也很简单，我们只需要实现正序倒序各遍历一次数组，求出每个位置的左右边界，计算水体积的时候直接查表，就可以成功地将复杂度压缩到 O(n)。&lt;/p&gt;

&lt;h5 id=&quot;problem-45&quot;&gt;Problem 45&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/jump-game-ii/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 我觉得这个问题是有难度的。我们很容易可以想出 O(n^2) 复杂度的解，但是我们需要用线性的时间来完成这道题。解决它的思路是使用 BFS 去搜索，但是我们不会将图给建起来，因为建图的代价本身就是 O(n^2)。这里用了一个小技巧来标记 BFS 的 level，那就是当前能达到的最远的点：一旦越过了这个点，那么我们就需要另一跳来达到它之后的点。&lt;/p&gt;

&lt;p&gt;还是举一个简单的例子：[2, 3, 1, 1, 4]，第一 level 是 2，因为 0 跳只能到起始点；第二 level 是 3， 1，因为根据 0 + 2 我们最远只能到 1 的位置；第三 level 是 1，4，因为 1 + 3 已经可以达到终点 4 了。&lt;/p&gt;

&lt;p&gt;算法做的事情很简单，线性地扫描一次数组，如果当前位置超过了当前最大值，那么跳数加一；如果没有则看当前位置加当前距离能否更新当前最大值。当走到终点时的跳数就是我们需要的答案。&lt;/p&gt;</content><author><name></name></author><category term="算法" /><summary type="html">为了找工作，题还是要刷起来~</summary></entry><entry><title type="html">如何写出高效的代码期末复习笔记</title><link href="/2019/05/09/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="如何写出高效的代码期末复习笔记" /><published>2019-05-09T21:00:00-07:00</published><updated>2019-05-09T21:00:00-07:00</updated><id>/2019/05/09/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2019/05/09/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课的内容很不错，但是质量并不是很好，慎选。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;photo&quot; src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Fast%20Code/Fast%20Code%20Final%20Cheat%20Sheet.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课的内容很不错，但是质量并不是很好，慎选。</summary></entry><entry><title type="html">面向服务的计算期末复习笔记</title><link href="/2019/05/07/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="面向服务的计算期末复习笔记" /><published>2019-05-07T21:00:00-07:00</published><updated>2019-05-07T21:00:00-07:00</updated><id>/2019/05/07/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2019/05/07/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课程所使用的教材是 Jia Zhang 老师自己编写的 Services Computing，课程内容其实相对老旧，不过我之前没有 Java 方面的经验，这门课还是让我学到了很多。&lt;/p&gt;

&lt;h4 id=&quot;week-1&quot;&gt;Week 1&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Generations of Software Engineering:
    &lt;ul&gt;
      &lt;li&gt;1st: Waterfall, compiler, OS, &lt;strong&gt;&lt;em&gt;programming language&lt;/em&gt;&lt;/strong&gt;;&lt;/li&gt;
      &lt;li&gt;2nd: Stuffs we learned in FSE (OOAD, patterns, modeling…);&lt;/li&gt;
      &lt;li&gt;3rd: SOC, &lt;strong&gt;&lt;em&gt;platform&lt;/em&gt;&lt;/strong&gt; is the key.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service operational models:
    &lt;ul&gt;
      &lt;li&gt;Hosted service model;&lt;/li&gt;
      &lt;li&gt;Business process outsourcing;&lt;/li&gt;
      &lt;li&gt;Data-center outsourcing;&lt;/li&gt;
      &lt;li&gt;Services through online broker agency.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service charge models:
    &lt;ul&gt;
      &lt;li&gt;Free-of-charge models;&lt;/li&gt;
      &lt;li&gt;Fee-based models;&lt;/li&gt;
      &lt;li&gt;Government service models.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service Level Agreement (SLA): Pay more for better service. Can support large user base and usage scenarios.&lt;/li&gt;
  &lt;li&gt;A service-oriented system is modeled as a feedback system.&lt;/li&gt;
  &lt;li&gt;Service lifecycle:
    &lt;ul&gt;
      &lt;li&gt;Consulting &amp;amp; strategic plan;&lt;/li&gt;
      &lt;li&gt;Service engagement;&lt;/li&gt;
      &lt;li&gt;Service delivery;&lt;/li&gt;
      &lt;li&gt;Service operation;&lt;/li&gt;
      &lt;li&gt;Billing.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Vertical services: Service industries (banking, telecom, …); Horizontal services: Commom services (Business services: CRM, …, has business logic, supports multiple scenarios; IT services: database, OS).&lt;/li&gt;
  &lt;li&gt;SOC is a discipline (umbrella); SOA is a architectural model (overall software system design); Web service is the best enabling technology.&lt;/li&gt;
  &lt;li&gt;Typical service system: &amp;lt;Inputs, Outputs, Goals, Transformation, Components, Sensors&amp;gt;.&lt;/li&gt;
  &lt;li&gt;IT-enabled service: Outsourcing of processes that can be enabled with information technology and covers diverse areas; It’s about relationship between providers and consumers.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-2&quot;&gt;Week 2&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;HTML and XML are both based on SGML (Standard Generalized Markup Language).&lt;/li&gt;
  &lt;li&gt;XML tags are case-sensitive.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;![CDATA[This is a comment]]&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Each XML document must have a unique first element: the root node.&lt;/li&gt;
  &lt;li&gt;DTD serves as the &lt;strong&gt;&lt;em&gt;grammar&lt;/em&gt;&lt;/strong&gt; for underlying XML document. Example:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-DTD&quot;&gt;&amp;lt;!DOCTYPE db[
    &amp;lt;!ELEMENT db(person*)&amp;gt;
    &amp;lt;!ELEMENT person(name, age, email)&amp;gt;
    &amp;lt;!ELEMENT name(#PCDATA)&amp;gt;
    &amp;lt;!ELEMENT age(#PCDATA)&amp;gt;
    &amp;lt;!ELEMENT email(#PCDATA)&amp;gt;
]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;XML Schema: Grammar for specifying valid XML documents. It is XML itself, so it’s verbose. Example:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;xs:element name=&quot;note&quot;&amp;gt;
    &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:sequence&amp;gt;
            &amp;lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot; /&amp;gt;
            &amp;lt;xs:element name=&quot;from&quot; type=&quot;xs:string&quot; /&amp;gt;
            &amp;lt;xs:element name=&quot;heading&quot; type=&quot;xs:string&quot; /&amp;gt;
            &amp;lt;xs:element name=&quot;body&quot; type=&quot;xs:string&quot; /&amp;gt;
        &amp;lt;/xs:sequence&amp;gt;
    &amp;lt;/xs:complexType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;DTD vs. XML Schema:
    &lt;ul&gt;
      &lt;li&gt;DTD (Old): Learning curve but terse;&lt;/li&gt;
      &lt;li&gt;XML Schema: Verbose but powerful (extensible, data types, namespaces).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XML parsing:
    &lt;ul&gt;
      &lt;li&gt;DOM (Document Object Model): Load whole XML document in memory: Faster;&lt;/li&gt;
      &lt;li&gt;SAX (Simple API for XML Parsing): Supports larger files.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XPath examples:&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/1.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/2.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;XQuery: For, Let, Where, Order by, Return (FLWOR). Example:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-XQuery&quot;&gt;for $x in doc(&quot;book.xml&quot;)/bookstore/book
where $x/price &amp;gt; 30
order by $x/title
return $x/title
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Other information:
    &lt;ul&gt;
      &lt;li&gt;JSON also has JSON Schema for validation;&lt;/li&gt;
      &lt;li&gt;Same Origin Policy (SOP): Full access to same origin (network, documents, storage, cookies);&lt;/li&gt;
      &lt;li&gt;XSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other documents;&lt;/li&gt;
      &lt;li&gt;XML data binding refers to the process of representing the information in an XML document as an object in computer memory.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-3&quot;&gt;Week 3&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;REST (Representational State Transfer) is a server-side technique; AJAX is a web technique which can only retrieve data from the server side. AJAX can be part of REST but REST can never be AJAX.&lt;/li&gt;
  &lt;li&gt;HTTP (Hypertext Transfer Protocol).&lt;/li&gt;
  &lt;li&gt;Mashup:
    &lt;ul&gt;
      &lt;li&gt;Pros: lightweight app, lightweight &amp;amp; rapid development, low cost for gathering data;&lt;/li&gt;
      &lt;li&gt;Cons: Dependency, versioning, copyright, security.&lt;/li&gt;
      &lt;li&gt;Component discovery &amp;amp; selection -&amp;gt; Composition &amp;amp; immediate deployment -&amp;gt; Use and evolution -&amp;gt; … (loop).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-4&quot;&gt;Week 4&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;WSDL (Web Service Description Language). WSDL 1.1 example:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;message name=&quot;getPriceRequest&quot;&amp;gt;
    &amp;lt;part name=&quot;productId&quot; type=&quot;xs:string&quot; /&amp;gt;
&amp;lt;/message&amp;gt;

&amp;lt;message name=&quot;getPriceResponse&quot;&amp;gt;
    &amp;lt;part name=&quot;value&quot; type=&quot;xs:string&quot; /&amp;gt;
&amp;lt;/message&amp;gt;

&amp;lt;portType name=&quot;productPrice&quot;&amp;gt;
    &amp;lt;operation&amp;gt;
        &amp;lt;input message=&quot;getPriceRequest&quot; /&amp;gt;
        &amp;lt;output message=&quot;getPriceResponse&quot; /&amp;gt;
    &amp;lt;/operation&amp;gt;
&amp;lt;/portType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;SOAP (Single Object Access Protocol) acts as the &lt;strong&gt;&lt;em&gt;messaging protocol&lt;/em&gt;&lt;/strong&gt; binding to HTTP and SMTP:
    &lt;ul&gt;
      &lt;li&gt;WSDL binding to SOAP: In WSDL, you will need to specify binding with SOAP, then you can write SOAP message to communicate with the service.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BPEL (Business Process Execution Language):
    &lt;ul&gt;
      &lt;li&gt;WSDL / REST supports a stateless model; While a business process (BP) is characterized by long-running, stateful sequence of operations;&lt;/li&gt;
      &lt;li&gt;Business process orchestration;&lt;/li&gt;
      &lt;li&gt;BPEL also has &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;throw&amp;gt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;catch&amp;gt;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;Example:&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/4.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/5.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WSRF (Web Services Resource Framework) is stateful.&lt;/li&gt;
  &lt;li&gt;WS-I (Web Services Interoperability) organization is to tackle the challenges of interoperability among web services by introducing conventions and best practices.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-5&quot;&gt;Week 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A web service can be published in a centralized services registry or a distributed services registry:
    &lt;ul&gt;
      &lt;li&gt;UDDI (Universal Description Discovery and Integration) registry is one typical example of centralized ~:
        &lt;ul&gt;
          &lt;li&gt;Four elements: BusinessEntity, BusinessService, BindingTemplate, tModel.&lt;/li&gt;
          &lt;li&gt;WSDL and UDDI:&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/7.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;UDDI Search Markup Language (USML) for supporting “Google” style services Search.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;WSIL (Web Services Inspection Language) is one example of publishing web services as distributed documents. Example:&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/6.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Advanced UDDI Search Engine (AUSE); Dynamic Service Discovery Framework (DSDF);&lt;/li&gt;
      &lt;li&gt;The federated framework provides a uniform interface for both UDDI-based and WSIL-based service discovery.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-7&quot;&gt;Week 7&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;LDA (Latent Dirichlet Allocation): Using Gibbs Sampling to calculate the result.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-10&quot;&gt;Week 10&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;MetaWSDL is a superset of WSDL: &lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/8.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;It should be published to the Internet associated with the original WSDL documents.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ESB (Enterprise Service Bus) consists of 4 components: mediators, services registry, choreographer, rule engine. ESB can do:
    &lt;ul&gt;
      &lt;li&gt;Routing;&lt;/li&gt;
      &lt;li&gt;Message transformation: XML to object),&lt;/li&gt;
      &lt;li&gt;Message enhancement: Supply data included in original data;&lt;/li&gt;
      &lt;li&gt;Protocol transformation;&lt;/li&gt;
      &lt;li&gt;Service mapping;&lt;/li&gt;
      &lt;li&gt;Message processing;&lt;/li&gt;
      &lt;li&gt;Process choreography: Co-ordination of multiple &lt;strong&gt;&lt;em&gt;business services&lt;/em&gt;&lt;/strong&gt;, usually BPEL-based;&lt;/li&gt;
      &lt;li&gt;Services orchestration: Co-ordination of multiple &lt;strong&gt;&lt;em&gt;implement services&lt;/em&gt;&lt;/strong&gt;, usually BPEL-based;&lt;/li&gt;
      &lt;li&gt;Transaction management;&lt;/li&gt;
      &lt;li&gt;Security.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SOA Reference Architecture (SOA-RA) partitions an SOA-based system into reusable achitecture components.&lt;/li&gt;
  &lt;li&gt;Service-Oriented Modeling and Architecture (SOMA) guides a generic engineering process. It identifies 3 steps: identification, specification, realization.&lt;/li&gt;
  &lt;li&gt;Different layers of web service standards:
    &lt;ul&gt;
      &lt;li&gt;Transport Layer: HTTP / HTTPS, SMTP (Simple Mail Transport Protocol, on port 25), RMI (Java Remote Method Invocation) / IIOP (Internet Inter-ORB Protocol), JMS (Java Message Service);&lt;/li&gt;
      &lt;li&gt;Messaging Layer: XML, SOAP, WS-Adressing, WS-Renewable;&lt;/li&gt;
      &lt;li&gt;Description / Publishing / Discovery Layer: XSD (XML Schema Definition), WSDL, WSRF (WS-Resource Framework), WS-Resource Properties (part of WSRF), UDDI, Others (WS-Based Faults, WS-Policy, WS-Metadata Exchange);&lt;/li&gt;
      &lt;li&gt;QoS (Quality of Service Layer): WS-Security, WS-Policy, WS-TM (WS-Transaction Management), WS-Reliable Messaging, WS-Resource Lifetime;&lt;/li&gt;
      &lt;li&gt;Service Composition Layer: SOAP + WSDL + UDDI, BPEL4WS, WS-Service Group, WS-Notification&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Industry-specific service-oriented standards:
    &lt;ul&gt;
      &lt;li&gt;Electronic Industry: RosettaNet.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-11&quot;&gt;Week 11&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;BPOL (Business Process Outsourcing Language).&lt;/li&gt;
  &lt;li&gt;SGA (Simple Genetic Algorithm) steps:
    &lt;ul&gt;
      &lt;li&gt;Select parents from population;&lt;/li&gt;
      &lt;li&gt;Shuffle mating pool;&lt;/li&gt;
      &lt;li&gt;For each pair, apply crossover with probability p&lt;sub&gt;c&lt;/sub&gt;;&lt;/li&gt;
      &lt;li&gt;For each offspring, apply mutation with probability p&lt;sub&gt;m&lt;/sub&gt; for each bit;&lt;/li&gt;
      &lt;li&gt;Replace old population with new offsprings.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutation-only-EA is possible, xover-only-EA won’t work.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-12&quot;&gt;Week 12&lt;/h4&gt;

&lt;p&gt;🍺&lt;/p&gt;

&lt;h4 id=&quot;week-13&quot;&gt;Week 13&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;RDF (Resource Description Framework):
    &lt;ul&gt;
      &lt;li&gt;It also has RDFS (RDF Schema): XMLS (XML Schema) is not an ontology language, while RDFS is an ontology language;&lt;/li&gt;
      &lt;li&gt;It is graphical formalism;&lt;/li&gt;
      &lt;li&gt;It supports containers: Bag, Seq, Alt.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;In graph database, we have: Subject –Predicate–&amp;gt; Object; In RDF statement, we have: Resource –Property–&amp;gt;Value.&lt;/li&gt;
  &lt;li&gt;Relational Database has tables with pre-defined schema, while RDF has knowledge without constraints.&lt;/li&gt;
  &lt;li&gt;SPARQL (SPARQL Protocol and RDF Query Language):
    &lt;ul&gt;
      &lt;li&gt;SELECT, ASK (return a boolean), DESCRIBE, CONSTRUCT;&lt;/li&gt;
      &lt;li&gt;FILTER, DISTINCT, ORDER BY, LIMIT, OFFSET;&lt;/li&gt;
      &lt;li&gt;UNION (like “or”), OPTIONAL;&lt;/li&gt;
      &lt;li&gt;FROM, FROM NAMED.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Turtle (Terse RDF Triple Language). Turtle and SPARQL example: &lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/9.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-14&quot;&gt;Week 14&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A more complex example of RDF: &lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/SOC/10.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;OWL (Web Ontology Language); OWL-S (Semantic Markup for Web Service).&lt;/li&gt;
  &lt;li&gt;WSMF (Web Service Modeling Framework).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-15&quot;&gt;Week 15&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A microservices architecture puts each element of functionality into a separate service. Modules run in different processes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;key-information&quot;&gt;Key Information&lt;/h4&gt;

&lt;h5 id=&quot;web-service-standard-stack&quot;&gt;Web Service Standard Stack&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Transport layer: Provides core communication and interactions for web services.
    &lt;ul&gt;
      &lt;li&gt;HTTP / HTTPS: Runs on 80 / 443; Over TCP; Request / response protocol to transfer information over the Internet;&lt;/li&gt;
      &lt;li&gt;SMTP: Runs on 25; Simple Mail Transfer Protocol; Text-based protocol to send mail over the Internet;&lt;/li&gt;
      &lt;li&gt;RMI / IIOP: Java Romote Method Invocation to create distributed Java-based app; Internet Inter-ORB Protocol is a tranport protocol for communication under CORBA;&lt;/li&gt;
      &lt;li&gt;JMS (Java Message Service): A standard for reliable enterprise messaging.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Messaging layer: Appropriately formats messages for exchanging information between web services.
    &lt;ul&gt;
      &lt;li&gt;XML: “Common language” for services to exchange information;&lt;/li&gt;
      &lt;li&gt;SOAP: A simple, lightweight protocol to exchange structured and typed information;&lt;/li&gt;
      &lt;li&gt;WS-Adressing: Identifies WS endpoints, and to secure end-to-end identifications in messages;&lt;/li&gt;
      &lt;li&gt;WS-Renewable: provides a mechanism for renewing reference to web resource.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Description / Publishing / Discovery layer: No need to explain.
    &lt;ul&gt;
      &lt;li&gt;XSD: XML Schema Definition, no need to explain;&lt;/li&gt;
      &lt;li&gt;WSDL: No need to explain;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;WS-Resource Property: Part of WSRF, describes how to view and modify web resourse;&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;UDDI: No need to explain;&lt;/li&gt;
      &lt;li&gt;WS-Base Faults: Defines an XML Schema type for base faults, and how they can be extended;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;WS-Policy: Describe capabilities, requirements and general characteristics of a WS;&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;WS-Metadata Exchange: Facilitate the retrieval of metadata from WS.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;QoS layer: Addresses the NFR of WS.
    &lt;ul&gt;
      &lt;li&gt;WS-Security: A set of mechanisms to secure SOAP message exchange;&lt;/li&gt;
      &lt;li&gt;WS-TM: “TM” for “Transaction Model”, protocols for managing transaction features in business activities;&lt;/li&gt;
      &lt;li&gt;WS-Resource Lifetime: To inspect and moniter the lifetime of WS and how WS can be destroyed;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service Composition Layer: Allows developers to compose services together for a common business goal.
    &lt;ul&gt;
      &lt;li&gt;BPEL4WS: No need to explain;&lt;/li&gt;
      &lt;li&gt;WS-Service Group: A wide variety of collections of web services or WS-Resources;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;WS-Notification: A set of specifications that provide support for events.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课程所使用的教材是 Jia Zhang 老师自己编写的 Services Computing，课程内容其实相对老旧，不过我之前没有 Java 方面的经验，这门课还是让我学到了很多。</summary></entry><entry><title type="html">软件工程基础期末复习笔记</title><link href="/2019/04/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="软件工程基础期末复习笔记" /><published>2019-04-20T21:00:00-07:00</published><updated>2019-04-20T21:00:00-07:00</updated><id>/2019/04/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2019/04/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;虽然本科的时候学过软件工程，但是知识早已忘光。因此我希望将这学期所学到的内容记录下来。&lt;/p&gt;

&lt;h4 id=&quot;week-1&quot;&gt;Week 1&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Evolution of Software Engineering:
    &lt;ul&gt;
      &lt;li&gt;Waterfall Approach;&lt;/li&gt;
      &lt;li&gt;Iterative &amp;amp; Incremental Approach:
        &lt;ul&gt;
          &lt;li&gt;Work is prioritized based on &lt;strong&gt;&lt;em&gt;risk&lt;/em&gt;&lt;/strong&gt;;&lt;/li&gt;
          &lt;li&gt;Examples: Spiral, Rational Unified Process (RUP).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Agile Approach:
        &lt;ul&gt;
          &lt;li&gt;Work is prioritized based on &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;;&lt;/li&gt;
          &lt;li&gt;Examples: XP, Scrum, Feature-Driven Development (FDD), Dynamic System Development Method (DSDM), Adaptive Software Development (ASD), Crystal Method.&lt;/li&gt;
          &lt;li&gt;Key barrier: Inability to change organization culture.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Lean Approach:
        &lt;ul&gt;
          &lt;li&gt;Optimize flows by reducing waste; Main prioritization criteria is still &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;;&lt;/li&gt;
          &lt;li&gt;From Toyota;&lt;/li&gt;
          &lt;li&gt;Examples: Lean, Kanban.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Hybrid Approach:
        &lt;ul&gt;
          &lt;li&gt;Examples: Scrumban, Scaled Agile Framework (SAFe), Disciplined Agile Delivery (DAD).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Agile:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Values&lt;/th&gt;
      &lt;th&gt;Practices&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Customer collaboration&lt;/td&gt;
      &lt;td&gt;Onsite customer (XP), Embedded product manager (Scrum)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Responding to change&lt;/td&gt;
      &lt;td&gt;Continuously updated &amp;amp; prioritized product backlog (Scrum)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Working software&lt;/td&gt;
      &lt;td&gt;Iterative Development (Sprints) &amp;amp; Sprint Review (Scrum)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Individuals and interations&lt;/td&gt;
      &lt;td&gt;Sprint retrospective (Scrum)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;XP:
    &lt;ul&gt;
      &lt;li&gt;Test first, pair programming, incremental design.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Other:
    &lt;ul&gt;
      &lt;li&gt;Scrum has “product owner”, “development team” and “Scrum master”, while Kanban has no roles;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-2&quot;&gt;Week 2&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Iron Triangle for Planning (Project Constraints):
    &lt;ul&gt;
      &lt;li&gt;Fixed-scope: Then variables are time and cost;&lt;/li&gt;
      &lt;li&gt;Fixed-date: Then varaible is scope.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Scope&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Quality&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cost&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;——-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Time&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;Definition of “Done” (DOD): two columns: Task/Action, Quality Check, or just one column like the ones on Trello;&lt;/li&gt;
  &lt;li&gt;People usually underestimate by a factor of 2;&lt;/li&gt;
  &lt;li&gt;Planning Poker combines analogy, disaggregation and expert judgment.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-3&quot;&gt;Week 3&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Four principles of OO:
    &lt;ul&gt;
      &lt;li&gt;Abstraction: Essential characteristics of an entity relative to certain perspective; Manage complexity by eliminating details;&lt;/li&gt;
      &lt;li&gt;Encapsulation: Facilitate information hiding; Manage complexity by grouping related elements into a single entity;&lt;/li&gt;
      &lt;li&gt;Hierachy: Ranking or ordering entities into a tree-like structure; Manage complexity by organizing into this tree-like structure:
        &lt;ul&gt;
          &lt;li&gt;Aggregation: is-part-of;&lt;/li&gt;
          &lt;li&gt;Inheritance: is-a-kind-of, implements polymorphos, which means having many forms;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Modularity: Manage complexity by breaking large entities into smaller, independent and cohesive modules (low coupling, high cohesion).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Apart from aggregation and inheritance, there’s association (knows-about relation);&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-4&quot;&gt;Week 4&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Analysis vs Design:
    &lt;ul&gt;
      &lt;li&gt;Analysis:
        &lt;ul&gt;
          &lt;li&gt;Focus on understanding the problem: WHAT;&lt;/li&gt;
          &lt;li&gt;Define behavior and structure;&lt;/li&gt;
          &lt;li&gt;Analysis classes, interaction diagrams, class diagrams.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Design:
        &lt;ul&gt;
          &lt;li&gt;Focus on understanding the solution: WHY;&lt;/li&gt;
          &lt;li&gt;System design: Define a robust architecture (Use case view, logical view, development view, process view, deployment view);&lt;/li&gt;
          &lt;li&gt;Object design: Refine the design of components and classes for easy implementation (Design patterns).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;OOAD is architecture-centric. OOAD toolset can be leveraged as needed to create “good enough” models.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;View of Participating Classes (VOPC).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-5&quot;&gt;Week 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Design patterns: Singleton; Bridge; Observer; Composite; Facade; Strategy; Factory Method; Adapter.&lt;/li&gt;
  &lt;li&gt;Hierarchy in Design Pattern (most basic mechanisms): Inheritance and Delegation;&lt;/li&gt;
  &lt;li&gt;SOLID Principles:
    &lt;ul&gt;
      &lt;li&gt;Single responsibility;&lt;/li&gt;
      &lt;li&gt;Open-closed principle: Open to extension, closed to modification;&lt;/li&gt;
      &lt;li&gt;Liskov’s substitution: One class can only be treated as a subtype of another if it can be substituted for the super class in every context;&lt;/li&gt;
      &lt;li&gt;Interface segregation: interfaces should be small and specialized;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_inversion_principle#/media/File:Dependency_inversion.png&quot;&gt;Dependency Inversion&lt;/a&gt;;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Other Principles:
    &lt;ul&gt;
      &lt;li&gt;Dependency injection: &lt;a href=&quot;https://piazza.com/class/jqrne75jnbw58q?cid=69&quot;&gt;link&lt;/a&gt;;&lt;/li&gt;
      &lt;li&gt;Inversion of control principle: Traditionally, we write main function which controls the flow; Now we use framework, we just fill in the blanks. Framework controls the flow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;7 ± 2 Rules: Number of subsystems, partitions, layers, functions per subsystem, components per subsystem should be no more than 9.&lt;/li&gt;
  &lt;li&gt;Architectural styles and patterns:
    &lt;ul&gt;
      &lt;li&gt;Architectural styles: Emphasize on organization, control flow, communication; More high level; Examples: Layered, pipe-and-filter, repository, client-server, peer-to-peer, event-based, hybrid/heterogeneous: compiler, REST, MVC;&lt;/li&gt;
      &lt;li&gt;Architectural patterns: Solve problems like security, federation, integration…;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Decomposition: Partitioning should increase cohesion, and layering should reduce coupling.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-6&quot;&gt;Week 6&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Technical practices: Pair programming, in-process testing, refactoring, version control (Diff based: CVS, SUBVERSION, file-based: git, mercurial&lt;/td&gt;
          &lt;td&gt;Centralized, distributed), continuous integration, incremental delivery.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-7&quot;&gt;Week 7&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Testing is a whole-team responsibility;&lt;/li&gt;
  &lt;li&gt;Components:
    &lt;ul&gt;
      &lt;li&gt;Entity Under Test (EUT);&lt;/li&gt;
      &lt;li&gt;Fixture: Test driver, test stub;&lt;/li&gt;
      &lt;li&gt;Test case:
        &lt;ul&gt;
          &lt;li&gt;Inputs or stimuli (triggers);&lt;/li&gt;
          &lt;li&gt;Oracle (expected behavior);&lt;/li&gt;
          &lt;li&gt;Outputs or results;&lt;/li&gt;
          &lt;li&gt;Assessment;&lt;/li&gt;
          &lt;li&gt;Verdict (pass or fail).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Others:
    &lt;ul&gt;
      &lt;li&gt;Test suite: collection of test cases;&lt;/li&gt;
      &lt;li&gt;Not all testing needs an oracle;&lt;/li&gt;
      &lt;li&gt;White-box testing misses unimplemented behaviors;&lt;/li&gt;
      &lt;li&gt;Black-box testing may miss unexpected behaviors;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-8&quot;&gt;Week 8&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Only intentional short-term focused debt and intentional long-term debt are healthy.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-9&quot;&gt;Week 9&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Defect repairs (maintenance) are usually the largest annual cost;&lt;/li&gt;
  &lt;li&gt;Fight against defects:
    &lt;ul&gt;
      &lt;li&gt;Defect prevention: Reuse, formal inspection;&lt;/li&gt;
      &lt;li&gt;Pre-test defect removal: Formal inspection, static analysis, Scrum daily stand-up meetings;&lt;/li&gt;
      &lt;li&gt;Testing defect removal: Software testing has low defect removal efficiency;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Best practice: Review fewer than 200-400 lines of code at a time, no more than 60-90 minutes at a time, inspection rate less than 300-500 LOC / hour at a time.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-10&quot;&gt;Week 10&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Requirements Envisioning:
    &lt;ul&gt;
      &lt;li&gt;Functional Requirements: Using Use Cases or User Stories;
        &lt;ul&gt;
          &lt;li&gt;INVEST criteria for stories: Independent, Negotiable, Valuable, Estimable, Small, Testable;&lt;/li&gt;
          &lt;li&gt;SMART criteria for tasks: Specific, Measurable, Achievable, Relevant, Time-boxed;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Non-Functional Requirements: Using Shall Statements or User Stories;&lt;/li&gt;
      &lt;li&gt;Validation: Using Prototypes;&lt;/li&gt;
      &lt;li&gt;Planning: Using Roadmaps and Backlogs;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Requirements Elaboration (just-in-time elaboration):
    &lt;ul&gt;
      &lt;li&gt;Use Case Specification (Basic Flow, Alternatives Flows);&lt;/li&gt;
      &lt;li&gt;User Story Acceptance Criteria (Given / When / Then);&lt;/li&gt;
      &lt;li&gt;Planguage for Non-Functional Requirements;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/FSE/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;week-11&quot;&gt;Week 11&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;External Qualities (Performance) &amp;amp; Internal Qualities (Testability);&lt;/li&gt;
  &lt;li&gt;Qualities Attributes of Architectural Styles:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Maintainability&lt;/th&gt;
      &lt;th&gt;Security&lt;/th&gt;
      &lt;th&gt;Reliability&lt;/th&gt;
      &lt;th&gt;Usability&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Layered&lt;/td&gt;
      &lt;td&gt;Key Strength&lt;/td&gt;
      &lt;td&gt;Key Strength&lt;/td&gt;
      &lt;td&gt;Strength&lt;/td&gt;
      &lt;td&gt;Neutral&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pipe and Filter&lt;/td&gt;
      &lt;td&gt;Strength&lt;/td&gt;
      &lt;td&gt;Liability&lt;/td&gt;
      &lt;td&gt;Key Liability&lt;/td&gt;
      &lt;td&gt;Liability&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MVC&lt;/td&gt;
      &lt;td&gt;Liability&lt;/td&gt;
      &lt;td&gt;Neutral&lt;/td&gt;
      &lt;td&gt;Neutral&lt;/td&gt;
      &lt;td&gt;Key Strength&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;Design patterns generally improve the expandability of code, and decrease reusability;&lt;/li&gt;
  &lt;li&gt;Quality Attribute Tradeoffs are asymmetric.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;others&quot;&gt;Others&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The behavior of the system can be modeled using a UML &lt;strong&gt;Use-case diagram&lt;/strong&gt;, Sequence diagram and Communication diagram.&lt;/li&gt;
  &lt;li&gt;The Facade pattern needs only delegations.&lt;/li&gt;
  &lt;li&gt;ES6 does not support class­-based inheritance.&lt;/li&gt;
  &lt;li&gt;Refactoring is enabled by in-process testing.&lt;/li&gt;
  &lt;li&gt;To be able to effectively test asynchronous behavior, we must isolate the behavior in a function, and make the side effect accessible to a test.&lt;/li&gt;
  &lt;li&gt;Technical debt is not incurred to save money in the long term.&lt;/li&gt;
  &lt;li&gt;“Feature debt”, or features in the backlog is not a type of technical debt.&lt;/li&gt;
  &lt;li&gt;Grace Hopper first came up with the term “bug”.&lt;/li&gt;
  &lt;li&gt;Latent defects: unknown defects, fixed defects, unfixed known defects.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">虽然本科的时候学过软件工程，但是知识早已忘光。因此我希望将这学期所学到的内容记录下来。</summary></entry><entry><title type="html">如何写出高效的代码期中复习笔记</title><link href="/2019/03/20/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="如何写出高效的代码期中复习笔记" /><published>2019-03-20T21:00:00-07:00</published><updated>2019-03-20T21:00:00-07:00</updated><id>/2019/03/20/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2019/03/20/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课的内容很不错，但是质量并不是很好，慎选。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;photo&quot; src=&quot;https://raw.githubusercontent.com/An0nym6/Images/master/blog%20images/Fast%20Code/Fast%20Code%20Cheat%20Sheet.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课的内容很不错，但是质量并不是很好，慎选。</summary></entry><entry><title type="html">面向服务的计算期中复习笔记</title><link href="/2019/03/03/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="面向服务的计算期中复习笔记" /><published>2019-03-03T20:00:00-08:00</published><updated>2019-03-03T20:00:00-08:00</updated><id>/2019/03/03/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2019/03/03/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课程所使用的教材是 Jia Zhang 老师自己编写的 Services Computing，课程内容其实相对老旧，不过我之前没有 Java 方面的经验，这门课还是让我学到了很多。&lt;/p&gt;

&lt;h4 id=&quot;week-1&quot;&gt;Week 1&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Generations of SE:
    &lt;ul&gt;
      &lt;li&gt;1st generation: Waterfall model, structured design &amp;amp; analysis, compilers, OS, &lt;strong&gt;programming languages&lt;/strong&gt;;&lt;/li&gt;
      &lt;li&gt;2nd generation: OO design &amp;amp; analysis, &lt;strong&gt;modeling&lt;/strong&gt;;&lt;/li&gt;
      &lt;li&gt;3rd generation: SOC &lt;strong&gt;platform&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service operation models:
    &lt;ul&gt;
      &lt;li&gt;Hosted service model;&lt;/li&gt;
      &lt;li&gt;Business process outsourcing;&lt;/li&gt;
      &lt;li&gt;Data-centered outsourcing;&lt;/li&gt;
      &lt;li&gt;Services through online broker agency.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service charge models:
    &lt;ul&gt;
      &lt;li&gt;Free-of-charge model;&lt;/li&gt;
      &lt;li&gt;Fee-based model;&lt;/li&gt;
      &lt;li&gt;Government service model.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service Level Agreement (SLA): Higher fee for higher quality of service. Support large user base and usage scenarios.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Service lifecycle&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;Strategic planning &amp;amp; consulting;&lt;/li&gt;
      &lt;li&gt;Service engagement;&lt;/li&gt;
      &lt;li&gt;Service delivery;&lt;/li&gt;
      &lt;li&gt;Service operation;&lt;/li&gt;
      &lt;li&gt;Service billing;&lt;/li&gt;
      &lt;li&gt;Service management.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Clarifications:
    &lt;ul&gt;
      &lt;li&gt;SOC is the umbrella, a discipline;&lt;/li&gt;
      &lt;li&gt;SOA is the architectural model (overall software system design);&lt;/li&gt;
      &lt;li&gt;Web service is the best enabling technology (to date).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Others:
    &lt;ul&gt;
      &lt;li&gt;IT-enabled service: Outsourcing of processes that can be enabled with information technology and covers diverse areas; Relationship between providers and consumers;&lt;/li&gt;
      &lt;li&gt;Differences between business services and IT services: One is about business logics, the other can support multiple scenarios;&lt;/li&gt;
      &lt;li&gt;Relationship between IT &amp;amp; non-IT services in a service ecosystem: Horizontal vs. vertical;&lt;/li&gt;
      &lt;li&gt;Describe a typical service system: Inputs, outputs, goals, transformation, components, sensors.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-2&quot;&gt;Week 2&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;XML:
    &lt;ul&gt;
      &lt;li&gt;One of the most important difference between XML and HTML is that XML is &lt;strong&gt;content-oriented&lt;/strong&gt; while HTML is &lt;strong&gt;presentation-oriented&lt;/strong&gt;;&lt;/li&gt;
      &lt;li&gt;XML is &lt;strong&gt;case-sensitive&lt;/strong&gt;;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;![CDATA[&amp;lt;tag&amp;gt;Here goes the comment&amp;lt;/tag&amp;gt;]]&amp;gt;&lt;/code&gt;;&lt;/li&gt;
      &lt;li&gt;Each document must have a unique first element – the root node.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DTD:
    &lt;ul&gt;
      &lt;li&gt;DTD serves as grammar for the underlying XML document, and it is part of XML language;&lt;/li&gt;
      &lt;li&gt;Example of DTD (PPT 3, Page 25);&lt;/li&gt;
      &lt;li&gt;DTD can be both inside XML file or outside XML file.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XML Schema:
    &lt;ul&gt;
      &lt;li&gt;Grammar for specifying valid XML documents, uses XML as well;&lt;/li&gt;
      &lt;li&gt;Example of XML Schema (PPT 3, Page 28);&lt;/li&gt;
      &lt;li&gt;DTD can only check the grammar of XML, while XML Schema can check if it’s both well-formed and valid:
        &lt;ul&gt;
          &lt;li&gt;DTD is not XML and terse;&lt;/li&gt;
          &lt;li&gt;XML Schema is XML and verbose and powerful (extensible to additions, data types, namespaces).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XML parsing:
    &lt;ul&gt;
      &lt;li&gt;DOM: Load whole XML into memory, fast;&lt;/li&gt;
      &lt;li&gt;SAX: Is better for large XML file, less memory.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XPath is used to navigate through elements and attributes in an XML document. Example on (PPT 3, Page 52).&lt;/li&gt;
  &lt;li&gt;XQuery is like the SQL to XML. Example on (PPT 3, 57).&lt;/li&gt;
  &lt;li&gt;Others:
    &lt;ul&gt;
      &lt;li&gt;JSON also has JSON Schema for validation;&lt;/li&gt;
      &lt;li&gt;Same Origin Policy (SOP): Full access to same origin (network, documents, storage, cookies);&lt;/li&gt;
      &lt;li&gt;XSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other documents;&lt;/li&gt;
      &lt;li&gt;XML data binding refers to the process of representing the information in an XML document as an object in computer memory.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-3&quot;&gt;Week 3&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;REST (Representational State Transfer)
    &lt;ul&gt;
      &lt;li&gt;Representational: Clients possess the information necessary to identify, modify, and/or delete a web resource;&lt;/li&gt;
      &lt;li&gt;State: All state information is stored on the client;&lt;/li&gt;
      &lt;li&gt;Transfer: State passed from client to server via HTTP;&lt;/li&gt;
      &lt;li&gt;Everything in REST is considered as a resource.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;REST vs AJAX: REST can do operations (PUT, POST, GET, HEAD), while AJAX can only retrieve data from the back-end. AJAX can be a part of REST but REST can never be AJAX.&lt;/li&gt;
  &lt;li&gt;Mashup:
    &lt;ul&gt;
      &lt;li&gt;Pros: “lightweight” application, “lightweight” development, low costs for gathering data, rapid development;&lt;/li&gt;
      &lt;li&gt;Cons: Dependency from data source, standards &amp;amp; versions, copyright, security;&lt;/li&gt;
      &lt;li&gt;Development process: Component discovery and selection -&amp;gt; Composition and immediate deployment -&amp;gt; Use and evolution -&amp;gt; loop…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-4&quot;&gt;Week 4&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;WSDL (Web Services Description Language): Service name, types of input parameters, types of output parameters…
    &lt;ul&gt;
      &lt;li&gt;WSDL 1.1 example on PPT 5, Page 13;&lt;/li&gt;
      &lt;li&gt;WSDL 2.0 example on PPT 5, Page 31.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SOAP (Simple Object Access Protocol): Messaging protocol for transport with binding to existing Internet protocols like HTTP and SMTP.
    &lt;ul&gt;
      &lt;li&gt;SOAP example on PPT 5, Page 21;&lt;/li&gt;
      &lt;li&gt;Example of binding WSDL to SOAP on PPT 5, Page 24.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BPEL (Business Process Execution Language):
    &lt;ul&gt;
      &lt;li&gt;BPM (Business Process Management);&lt;/li&gt;
      &lt;li&gt;Example on PPT 5, Page 47-62.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Others:
    &lt;ul&gt;
      &lt;li&gt;Web Services Resources Property (WSRP): Stateful;&lt;/li&gt;
      &lt;li&gt;Web Services Interoperability (WS-I): To tackle the challenges of interoperability among Web services.&lt;/li&gt;
      &lt;li&gt;Service provider creates, publishes, and operates services. Service customer uses services. Service broker helps service customer find interested services.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-5&quot;&gt;Week 5&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;WSIL (Web services Inspection Language) example on PPT 6, Page 7.&lt;/li&gt;
  &lt;li&gt;UDDI (Universal Description Discovery and Integration):
    &lt;ul&gt;
      &lt;li&gt;Data model: businessEntity, businessService, bindingTemplate, tModel.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UDDI Search Markup Language (USML) for supporting “Google” style services Search.&lt;/li&gt;
  &lt;li&gt;Others:
    &lt;ul&gt;
      &lt;li&gt;Advanced UDDI Search Engine (AUSE);&lt;/li&gt;
      &lt;li&gt;Dynamic Service Discovery Framework (DSDF);&lt;/li&gt;
      &lt;li&gt;The federated framework provides a uniform interface for both UDDI-based and WSIL-based service discovery.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;week-7&quot;&gt;Week 7&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Latent Dirichlet Allocation (LDA).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;others&quot;&gt;Others&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Pros of SOC: Reusability, interoperability.&lt;/li&gt;
  &lt;li&gt;Services ecosystem: How all of the services can work together and what are their relationships.&lt;/li&gt;
  &lt;li&gt;DTD:
    &lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt; &amp;lt;!DOCTYPE bookshelf [
     &amp;lt;!ELEMENT bookshelf (book*)&amp;gt;
     &amp;lt;!ELEMENT book (author, content)&amp;gt;
     &amp;lt;!ELEMENT author (#PCDATA)&amp;gt;
     &amp;lt;!ELEMENT content (#PCDATA)&amp;gt;
 ]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;XML Schema:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt; &amp;lt;xs:element name=&quot;bookshelf&quot;&amp;gt;
     &amp;lt;xs:complexType&amp;gt;
         &amp;lt;xs:sequence&amp;gt;
             &amp;lt;xs:element name=&quot;author&quot; type=&quot;xs:string&quot; /&amp;gt;
             &amp;lt;xs:element name=&quot;content&quot; type=&quot;xs:string&quot; /&amp;gt;
         &amp;lt;/xs:sequence&amp;gt;
     &amp;lt;/xs:complexType&amp;gt;
 &amp;lt;/xs:element&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;WSDL 1.1:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt; &amp;lt;message name=&quot;getCreditReq&quot;&amp;gt;
     &amp;lt;part name=&quot;cardNum&quot; type=&quot;xs:string&quot; /&amp;gt;
     &amp;lt;part name=&quot;ssn&quot; type=&quot;xs:string&quot; /&amp;gt;
 &amp;lt;/message&amp;gt;
 &amp;lt;message name=&quot;getCreditRes&quot;&amp;gt;
     &amp;lt;part name=&quot;namw&quot; type=&quot;xs:string&quot; /&amp;gt;
     &amp;lt;part name=&quot;address&quot; type=&quot;xs:string&quot; /&amp;gt;
     &amp;lt;part name=&quot;accountBalance&quot; type=&quot;xs:string&quot; /&amp;gt;
 &amp;lt;/message&amp;gt;
 &amp;lt;portType name=&quot;personalCredit&quot;&amp;gt;
     &amp;lt;operation name=&quot;getCredit&quot;&amp;gt;
         &amp;lt;input message=&quot;getCreditReq&quot; /&amp;gt;
         &amp;lt;output message=&quot;getCreditRes&quot; /&amp;gt;
     &amp;lt;/operation&amp;gt;
 &amp;lt;/portType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;WSDL 2.0:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt; &amp;lt;types&amp;gt;
     &amp;lt;schema&amp;gt;
         &amp;lt;element name=&quot;getCreditReq&quot;&amp;gt;
             &amp;lt;complexType&amp;gt;
                 &amp;lt;element name=&quot;cardNum&quot; type=&quot;xs:string&quot; /&amp;gt;
                 &amp;lt;element name=&quot;ssn&quot; type=&quot;xs:string&quot; /&amp;gt;
             &amp;lt;/complexType&amp;gt;
         &amp;lt;/element&amp;gt;
         &amp;lt;element name=&quot;getCreditRes&quot;&amp;gt;
             &amp;lt;complexType&amp;gt;
                 &amp;lt;element name=&quot;name&quot; type=&quot;xs:string&quot; /&amp;gt;
                 &amp;lt;element name=&quot;address&quot; type=&quot;xs:string&quot; /&amp;gt;
                 &amp;lt;element name=&quot;accountBalance&quot; type=&quot;xs:string&quot; /&amp;gt;
             &amp;lt;/complexType&amp;gt;
         &amp;lt;/element&amp;gt;
     &amp;lt;/schema&amp;gt;
 &amp;lt;/types&amp;gt;
 &amp;lt;interface name=&quot;personalCredit&quot;&amp;gt;
     &amp;lt;operation name=&quot;getCredit&quot;&amp;gt;
         &amp;lt;input messageLabel=&quot;In&quot; element=&quot;getCreditReq&quot; /&amp;gt;
         &amp;lt;output messageLabel=&quot;Out&quot; element=&quot;getCreditRes&quot; /&amp;gt;
     &amp;lt;/operation&amp;gt;
 &amp;lt;/interface&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;UDDI data model:
    &lt;ul&gt;
      &lt;li&gt;Business entity;&lt;/li&gt;
      &lt;li&gt;Business service: service;&lt;/li&gt;
      &lt;li&gt;Binding template: port;&lt;/li&gt;
      &lt;li&gt;Technical models (tModel): service interface.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UDDI for centralized web service publishing: Can’t dynamically updated; WSIL for distributed web service publishing: No uniform way to query a web service, and tModel is not stored in UDDI.&lt;/li&gt;
  &lt;li&gt;&amp;lt;​partnerLinkType&amp;gt; d​escribes the way two business partners interact.&lt;/li&gt;
  &lt;li&gt;Relations between service broker, service consumer and service provider:
    &lt;ul&gt;
      &lt;li&gt;Service provider - WSDL (publish or announce) -&amp;gt; service broker;&lt;/li&gt;
      &lt;li&gt;Service consumer - UDDI (find or discover) -&amp;gt; service broker;&lt;/li&gt;
      &lt;li&gt;Service consumer &amp;lt;- SOAP (invoke or bind) -&amp;gt; service provider.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BPEL supports long-running, stateful sequence, while WSDL supports a single, stateless model.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课程所使用的教材是 Jia Zhang 老师自己编写的 Services Computing，课程内容其实相对老旧，不过我之前没有 Java 方面的经验，这门课还是让我学到了很多。</summary></entry><entry><title type="html">算法期末复习笔记</title><link href="/2018/11/29/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="算法期末复习笔记" /><published>2018-11-29T20:00:00-08:00</published><updated>2018-11-29T20:00:00-08:00</updated><id>/2018/11/29/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/11/29/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课程所使用的教材是康奈尔的 Algorithm Design 和 MIT 的 Introduction to Algorithms，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。&lt;/p&gt;

&lt;h4 id=&quot;lecture-5&quot;&gt;Lecture 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Steps for solving DP problems:
    &lt;ol&gt;
      &lt;li&gt;Describe subproblem;&lt;/li&gt;
      &lt;li&gt;Describe base case;&lt;/li&gt;
      &lt;li&gt;Describe recurrence;&lt;/li&gt;
      &lt;li&gt;Analyze complexity;&lt;/li&gt;
      &lt;li&gt;Write pseudo code.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-6&quot;&gt;Lecture 6&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Shortest path:
    &lt;ul&gt;
      &lt;li&gt;Single source &amp;amp; positive-weighted: Dijkstra’s Algorithm;&lt;/li&gt;
      &lt;li&gt;Single source &amp;amp; negative-weighted: Bellman-Ford Algorithm;
        &lt;ul&gt;
          &lt;li&gt;Case 1: D[v, k] = D[v, k - 1], path uses at most k - 1 edges;&lt;/li&gt;
          &lt;li&gt;Case 2: D[v, k] = min&lt;sub&gt;(w, v)∈E&lt;/sub&gt;(D[w, k - 1] + C&lt;sub&gt;wv&lt;/sub&gt;);&lt;/li&gt;
          &lt;li&gt;Goal: Compute D(t, v - 1);&lt;/li&gt;
          &lt;li&gt;Complexity: O(EV);&lt;/li&gt;
          &lt;li&gt;Negative cycle? Run 1 more round for k = v, if D decrease for some point, then yes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;All-pairs: 1. Run Bellman-Ford V times: O(EV&lt;sup&gt;2&lt;/sup&gt;); 2. Floyd-Warshall Algorithm;
        &lt;ul&gt;
          &lt;li&gt;D[i, j, k] = min&lt;sub&gt;u&lt;/sub&gt;(D[i, u, k - 1] + D[u, j, k - 1], D[i, j, k - 1]);&lt;/li&gt;
          &lt;li&gt;Pseudo code:
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  D[i,j,V[0]] = c[i,j] for all i and j
  for k in V:
    for i in V:
      for j in V:
        D[i,j,k] = min(D[i,k,k-1]+D[k,j,k-1],D[i,j,k-1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;Complexity: O(V&lt;sup&gt;3&lt;/sup&gt;)&lt;/li&gt;
          &lt;li&gt;Negative cycle? If the diagonal has nagetive elements, then yes;&lt;/li&gt;
          &lt;li&gt;Extract the shortest path? Every time we update D[i, j], we set P[i, j] to k. Then we recursively compute the shortest path from i to k = P[i, j] and the path from k = P[i, j] to j.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-7&quot;&gt;Lecture 7&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Max-flow problem: Ford-Fulkerson Algorithm:
    &lt;ul&gt;
      &lt;li&gt;Complexity: O(|f|(E + V));&lt;/li&gt;
      &lt;li&gt;Edmonds-Karp Algorithm: If we replace DFS with BFS, the complexity would be O(E&lt;sup&gt;2&lt;/sup&gt;V);&lt;/li&gt;
      &lt;li&gt;Capacity-Scaling Algorithm: If we choose the augmenting path with highest bottleneck capacity, the complexity would be O(log|f|E&lt;sup&gt;2&lt;/sup&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Max-flow theorem: the following conditions are equivalent for any f:
    &lt;ul&gt;
      &lt;li&gt;∃ cut(A, B) s.t. cap(A, B) = |f|;&lt;/li&gt;
      &lt;li&gt;f is a max-flow;&lt;/li&gt;
      &lt;li&gt;There is no augmenting path wrt to f.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Value of the max-flow = capacity of the min-cut.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Applications of max-flow:
    &lt;ul&gt;
      &lt;li&gt;Bipartite max matching: |f| ≤ V, V’ = 2V, so complexity: O(V(E + 2V)) = O(EV).&lt;/li&gt;
      &lt;li&gt;Maximum number of edge disjoint paths. Complexity: O(EV)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-8&quot;&gt;Lecture 8&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Image segmentation problem: solved by min-cut problem.&lt;/li&gt;
  &lt;li&gt;Circulation problem can be reduced to max-flow problem: there is a feasible circulation in G if and only if the max-flow can achieve Σ&lt;sub&gt;d(v)&amp;gt;0&lt;/sub&gt;d(v).&lt;/li&gt;
  &lt;li&gt;Circulation problem with demands can be reduced to circulation problem without demands: just push the lower bounds of flow through each edges, then modify the capacity of each edge and demand of each vertex respectively.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Survey Design Problem.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-9&quot;&gt;Lecture 9&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Undecidable problems: there is no computer program that can always give the right answer: it may give the wrong answer, or run forever. NP-Hard contains undecidable problems.
    &lt;ul&gt;
      &lt;li&gt;Example: The halting problem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;To prove X is in NP-Complete, we first prove X is in NP (answer can be verified in polynomial time), then we prove X is in NP-Hard (∃Y ∈ NP, Y ≤&lt;sub&gt;p&lt;/sub&gt; X).&lt;/li&gt;
  &lt;li&gt;NP-Complete problems are the most difficult NP problems.&lt;/li&gt;
  &lt;li&gt;Reductions of NP-Complete problems:
    &lt;ul&gt;
      &lt;li&gt;SAT is in NP-Complete without proof;&lt;/li&gt;
      &lt;li&gt;3-SAT ≤&lt;sub&gt;p&lt;/sub&gt; Independent set;&lt;/li&gt;
      &lt;li&gt;Independent set ≤&lt;sub&gt;p&lt;/sub&gt; Vertex cover;&lt;/li&gt;
      &lt;li&gt;Vertex cover ≤&lt;sub&gt;p&lt;/sub&gt; Vertex cover-even;&lt;/li&gt;
      &lt;li&gt;3-SAT ≤&lt;sub&gt;p&lt;/sub&gt; 3-colorable;&lt;/li&gt;
      &lt;li&gt;3-SAT ≤&lt;sub&gt;p&lt;/sub&gt; Hamiltonian Cycle (without proof).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-10&quot;&gt;Lecture 10&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Standard linear programming problem in matrix form:&lt;br /&gt;
 max(c&lt;sup&gt;T&lt;/sup&gt;x),&lt;br /&gt;
 subject to: Ax ≤ b, x ≥ 0.
    &lt;ul&gt;
      &lt;li&gt;Linear programming can be used to solve max-flow and shortest path problem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Integer linear programming (ILP) is in NP-Hard.
    &lt;ul&gt;
      &lt;li&gt;Independent set ≤&lt;sub&gt;p&lt;/sub&gt; ILP;&lt;/li&gt;
      &lt;li&gt;ILP can be used to solve 0-1 Knapsack.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The dual of standard linear programming problem:&lt;br /&gt;
 min(b&lt;sup&gt;T&lt;/sup&gt;y),&lt;br /&gt;
 subject to: A&lt;sup&gt;T&lt;/sup&gt;y ≥ c, y ≥ 0.
    &lt;ul&gt;
      &lt;li&gt;The weak duality: if x is a feasible solution for primal and y is a feasible solution for dual, then c&lt;sup&gt;T&lt;/sup&gt;x ≤ b&lt;sup&gt;T&lt;/sup&gt;y;&lt;/li&gt;
      &lt;li&gt;The strong duality: opt(primal) = opt(dual);&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;P \ D&lt;/th&gt;
              &lt;th&gt;F.B.&lt;/th&gt;
              &lt;th&gt;F.U.&lt;/th&gt;
              &lt;th&gt;I.&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;F.B.&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;F.U.&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;I.&lt;/td&gt;
              &lt;td&gt;No&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
              &lt;td&gt;Yes&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;General form of primal and dual:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Primal&lt;/th&gt;
          &lt;th&gt;Dual&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;max(c&lt;sup&gt;T&lt;/sup&gt;x)&lt;/td&gt;
          &lt;td&gt;min(b&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;1&lt;/sub&gt; + b&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;2&lt;/sub&gt; + b&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;3&lt;/sub&gt;)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A&lt;sub&gt;1&lt;/sub&gt;x ≤ b&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
          &lt;td&gt;A&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;1&lt;/sub&gt; + A&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;2&lt;/sub&gt; + A&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;y&lt;sub&gt;3&lt;/sub&gt; ≥ c&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A&lt;sub&gt;2&lt;/sub&gt;x = b&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;
          &lt;td&gt;y&lt;sub&gt;1&lt;/sub&gt; ≥ 0&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;A&lt;sub&gt;3&lt;/sub&gt;x ≥ b&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
          &lt;td&gt;y&lt;sub&gt;2&lt;/sub&gt; unrestricted&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;x ≥ 0&lt;/td&gt;
          &lt;td&gt;y&lt;sub&gt;3&lt;/sub&gt; ≤ 0&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-11&quot;&gt;Lecture 11&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Classic approximation algorithms:
    &lt;ul&gt;
      &lt;li&gt;2-approximation vertex cover: find matchings in graph;&lt;/li&gt;
      &lt;li&gt;2-approximation TSP on complete graph with triangle inequality: use MST;&lt;/li&gt;
      &lt;li&gt;1.5-approximation TSP on complete graph with triangle inequality:
        &lt;ul&gt;
          &lt;li&gt;MST of G → T;&lt;/li&gt;
          &lt;li&gt;Vertices of odd degree in T → S;&lt;/li&gt;
          &lt;li&gt;Min-cost matching on S → M;&lt;/li&gt;
          &lt;li&gt;return T ∪ M.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;There is no polynomial α-approximation algorithm for general TSP: if such algorithm exists, we can use it to solve Hamiltonian Cycle.&lt;/li&gt;
      &lt;li&gt;ln n-approximation set cover: greedy, each move covers at least 1/k of the elements, so k * ln n moves will cover all (k is the optimal).&lt;/li&gt;
      &lt;li&gt;2-approximation load balance: greedy: assign next job to the machine with least load.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-12&quot;&gt;Lecture 12&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Classification of random algorithm:
    &lt;ul&gt;
      &lt;li&gt;Las Vegas algorithms: always returns the correct answer, but may run longer than you expect.
        &lt;ul&gt;
          &lt;li&gt;Example: quick sort.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Monte Carlo algorithms: may fail or return incorrect answer, but the runtime is independent of input randomness.
        &lt;ul&gt;
          &lt;li&gt;Example: random global min-cut.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Random data structre:
    &lt;ul&gt;
      &lt;li&gt;Skip list: O(log n) search time;&lt;/li&gt;
      &lt;li&gt;Treap: a binary search tree with the heap ordering property (use rotation to maintain heap ordering property while do no change to BST ordering property).
        &lt;ul&gt;
          &lt;li&gt;Complexity: O(log n) search time &amp;amp; O(log n) insert time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课程所使用的教材是康奈尔的 Algorithm Design 和 MIT 的 Introduction to Algorithms，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。</summary></entry><entry><title type="html">AI 第三部分“机器学习”复习笔记</title><link href="/2018/11/24/AI-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="AI 第三部分“机器学习”复习笔记" /><published>2018-11-24T20:00:00-08:00</published><updated>2018-11-24T20:00:00-08:00</updated><id>/2018/11/24/AI%20%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%9D%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/11/24/AI-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课程所使用的教材是 Artificial Intelligence: A Modern Approach，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。&lt;/p&gt;

&lt;h4 id=&quot;lecture-18-19&quot;&gt;Lecture 18-19&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Bayes’ rule: P(A|B) = (P(B|A) · P(A)) / P(B).&lt;/li&gt;
  &lt;li&gt;Normalization &amp;amp; marginalization: P(X|e) = P(X, e) / P(e) = α · P(X, e) = α · Σ&lt;sub&gt;y&lt;/sub&gt; P(X, e, y).&lt;/li&gt;
  &lt;li&gt;In the alarm network, calls are conditionally independent of burglaries and earthquakes, but not independent of them.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-20&quot;&gt;Lecture 20&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Entropy: -Σ&lt;sub&gt;i&lt;/sub&gt; P(v&lt;sub&gt;i&lt;/sub&gt;) · ln(P(v&lt;sub&gt;i&lt;/sub&gt;)):
    &lt;ul&gt;
      &lt;li&gt;The more uniform the probability distribution, the greater its information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ID3 algorithm: Top-down construction of decision tree by recursively selecting “best attribute” to use at the current node in tree.
    &lt;ul&gt;
      &lt;li&gt;“best attribute”: Choose the attribute that has the largest expected information gain.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-20-21&quot;&gt;Lecture 20-21&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Back-propagation is synchronous while Hopfield net is asynchronous; Back-propagation tries to minimize the error while Hopfield net tries to minimize the energy.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-22&quot;&gt;Lecture 22&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Markov Decision Process (MDP):
    &lt;ul&gt;
      &lt;li&gt;The problem is to find the optimal policy, which maximizes utility at each state;&lt;/li&gt;
      &lt;li&gt;Bellman equation: U(s) = R(s) + γ max&lt;sub&gt;a&lt;/sub&gt;(Σ&lt;sub&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/sub&gt;(P(s&lt;sub&gt;1&lt;/sub&gt; | s, a) · U(s&lt;sub&gt;1&lt;/sub&gt;))). Repeating this formula will converge to optimal policy.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-23&quot;&gt;Lecture 23&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Reinforcement Learning:
    &lt;ul&gt;
      &lt;li&gt;Utility-based agent: if it already knows the transition model, then use MDP algorithm to solve for Maximum Expectation Utility (MEU) actions.&lt;/li&gt;
      &lt;li&gt;Q-learning agent: if it doesn’t know the transition model, then pick action that has highest utility in current state.&lt;br /&gt;
        &lt;ul&gt;
          &lt;li&gt;Q(s, a) = Q(s, a) + α(R(s) + γ max&lt;sub&gt;a’&lt;/sub&gt; (Q(s’, a’) − Q(s, a))) →&lt;br /&gt;
  Q(s, a) = (1 - α)Q(s, a) + α(R(s) + γ max&lt;sub&gt;a’&lt;/sub&gt; Q(s’, a’))&lt;/li&gt;
          &lt;li&gt;Converge to correct values if α decays over time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Reflex agent: learn a policy directly, then pick the action that the policy says.
        &lt;ul&gt;
          &lt;li&gt;Can start right away and then learn as it goes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-24-25&quot;&gt;Lecture 24-25&lt;/h4&gt;

&lt;p&gt;Guest speaker.&lt;/p&gt;

&lt;h4 id=&quot;lecture-26&quot;&gt;Lecture 26&lt;/h4&gt;

&lt;p&gt;🍺&lt;/p&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课程所使用的教材是 Artificial Intelligence: A Modern Approach，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。</summary></entry><entry><title type="html">AI 第二部分“逻辑”复习笔记</title><link href="/2018/10/26/AI-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%80%BB%E8%BE%91-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="AI 第二部分“逻辑”复习笔记" /><published>2018-10-26T21:00:00-07:00</published><updated>2018-10-26T21:00:00-07:00</updated><id>/2018/10/26/AI%20%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E2%80%9C%E9%80%BB%E8%BE%91%E2%80%9D%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/10/26/AI-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%80%BB%E8%BE%91-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课程所使用的教材是 Artificial Intelligence: A Modern Approach，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。&lt;/p&gt;

&lt;h4 id=&quot;lecture-9-10&quot;&gt;Lecture 9-10&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Syntax (语法): how sentences are expressed; semantics (语义): meaning of the sentence, e.g., truth value.&lt;/li&gt;
  &lt;li&gt;If a sentence α is true in model m, we say m satisfies α, or m is a model of α:
    &lt;ul&gt;
      &lt;li&gt;M(α) is the set of all models of α; M(KB) is the set of all models of KB;&lt;/li&gt;
      &lt;li&gt;KB ⊨ α if and only if M(KB) is a subset M(α).&lt;/li&gt;
      &lt;li&gt;KB ⊨ α: KB entails sentence α, if and only if, α is true in all worlds where KB is true.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Entailment (⊨) is different from inference (⊢). Think of inference a the process of finding the entailment:
    &lt;ul&gt;
      &lt;li&gt;KB ⊢i α = sentence α can be derived from KB by procedure i.&lt;/li&gt;
      &lt;li&gt;Soundness: i is sound if whenever KB ⊢i α, it is also true that KB ⊨ α.&lt;/li&gt;
      &lt;li&gt;Completeness: i is complete if whenever KB ⊨ α, it is also true that KB ⊢i α.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Proof methods:
    &lt;ol&gt;
      &lt;li&gt;Model checking: Truth table enumeration (sound and complete); Heuristic search in model space (sound but incomplete);&lt;/li&gt;
      &lt;li&gt;Application of inference rules.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;A sentence is valid if it is true in all models (tautologies); A sentence is satisfiable if it is true in at least one model.
    &lt;ul&gt;
      &lt;li&gt;α is valid if and only if ¬α is unsatisfiable;&lt;/li&gt;
      &lt;li&gt;α is satisfiable if and only if ¬α is not valid.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Names for important tautologies:
    &lt;ul&gt;
      &lt;li&gt;Commutativity of ⋀ / ⋁: 交换律&lt;/li&gt;
      &lt;li&gt;Associativity of ⋀ / ⋁: 结合律&lt;/li&gt;
      &lt;li&gt;Double-negation elimination&lt;/li&gt;
      &lt;li&gt;Contraposition: α ⇒ β ⇔ ¬β ⇒ ¬α&lt;/li&gt;
      &lt;li&gt;Implication elimination&lt;/li&gt;
      &lt;li&gt;Biconditional elimination&lt;/li&gt;
      &lt;li&gt;De Morgan&lt;/li&gt;
      &lt;li&gt;Distributivity of ⋀ / ⋁ over ⋁ / ⋀: 分配律&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;α ⊨ β if and only if the sentence (α ⋀ ¬β) is unsatisfiable.&lt;/li&gt;
  &lt;li&gt;Names for inference rules:
    &lt;ul&gt;
      &lt;li&gt;Modus ponens: from α ⇒ β, α, we get β&lt;/li&gt;
      &lt;li&gt;Modus tollens: from α ⇒ β, ¬β, we get ¬α&lt;/li&gt;
      &lt;li&gt;And-elimination: from α ⋀ β, we get α&lt;/li&gt;
      &lt;li&gt;Or-introduction: from α, we get α ⋁ β&lt;/li&gt;
      &lt;li&gt;Both directions of all tautologies like contraposition: (α ⇒ β) ⇔ (¬β ⇒ ¬α)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-11-12&quot;&gt;Lecture 11-12&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Resolution Inference: Complete when coupled with complete search algorithm.
    &lt;ul&gt;
      &lt;li&gt;To prove that KB ⊨ α, we show that (KB ⋀ ¬α) is unsatisfiable:
        &lt;ol&gt;
          &lt;li&gt;Convert (KB ⋀ ¬α) to CNF;&lt;/li&gt;
          &lt;li&gt;Apply the resolution rule wherever possible and add the result as an additional clause in the conjunction;&lt;/li&gt;
          &lt;li&gt;Repeat step 2 until either:
            &lt;ul&gt;
              &lt;li&gt;No new clauses can be added: KB does not entail α.&lt;/li&gt;
              &lt;li&gt;Two clauses resolve to yield the empty clause: KB entails α.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If each clause is a horn clause in KB and the queries are atomic, then we can use linear-time algorithm forward chaining and backward chaining to do the inference. Complexity for backward chaining can be much less than linear in size of KB.&lt;/li&gt;
  &lt;li&gt;Symbols for constants, predicates and functions usually start with upper-case letters; Variables are written in lowercase letters.&lt;/li&gt;
  &lt;li&gt;⇒ is a natural connective to use with ∀; ⋀ is a natural connective to use with ∃.&lt;/li&gt;
  &lt;li&gt;De Morgan for quantifier negation: ¬∀x P ⇔ ∃x ¬P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-13&quot;&gt;Lecture 13&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A ground literal’s terms are all ground terms; A ground term is a term without variables.&lt;/li&gt;
  &lt;li&gt;SUBST(θ, α): rewrite a sentence, α, by applying substitution, θ.&lt;/li&gt;
  &lt;li&gt;For every unifiable pair of expressions there is a Most General Unifier (a unique substitution) that equates the pair while making the fewest restrictions on the values of the variables.&lt;/li&gt;
  &lt;li&gt;First-order definite clauses are disjunctions of literals, of which exactly one is positive:
    &lt;ul&gt;
      &lt;li&gt;Atomic sentences (positive literals) are also definite clauses;&lt;/li&gt;
      &lt;li&gt;Definite clauses can include variables. The variables are assumed to be universally quantified.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datalog Knowledge base contains only first-order definite clauses with no function symbols.&lt;/li&gt;
  &lt;li&gt;Forward chaining is sound and complete for first-order definete clauses. We can use CSP heuristics like Minimum-Remaining Value to imporve efficiency. We can also do incremental forward chaining – only consider rules with premise that involves a literal that can unify with the facts newly inferred from the previous iteration.&lt;/li&gt;
  &lt;li&gt;Backward chaining is sound but incomplete due to infinite loops. But it’s linear in size of proof.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-14&quot;&gt;Lecture 14&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Herbrand’s theorem: If there is a proof that a sentence is entailed by the original first-order knowledge base, then there is a proof involving just a finite subset of the propositionalized knowledge base. Entailment for first-order logic is semidecidable. We can say yes to every entailed sentence, but there is no way to say no to every non-entailed sentence.&lt;/li&gt;
  &lt;li&gt;CNF conversion for first-order logic:
    &lt;ol&gt;
      &lt;li&gt;Eliminate implications;&lt;/li&gt;
      &lt;li&gt;Move ¬ inward;&lt;/li&gt;
      &lt;li&gt;Standardize variables;&lt;/li&gt;
      &lt;li&gt;Skolemization;
        &lt;ul&gt;
          &lt;li&gt;Unique function names;&lt;/li&gt;
          &lt;li&gt;Arguments for all of the universally quantified variables in whose scope the existential quantifier appears;&lt;/li&gt;
          &lt;li&gt;We used Skolem Constants to remove existential quantifiers when the sentence was in a specific form (存在量词在最外面);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Drop universal quantifiers;&lt;/li&gt;
      &lt;li&gt;Distribute ⋁ over ⋀.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Russell’s Paradox:
    &lt;ul&gt;
      &lt;li&gt;The paradox arises within naive set theory by considering the set of all sets that are not members of themselves.&lt;/li&gt;
      &lt;li&gt;A master catalog of all library catalogs which do not include themselves.&lt;/li&gt;
      &lt;li&gt;A barber who shaves exactly those people who do not shave themselves.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Prolog.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(不知道为什么没有 Lecture 15)&lt;/p&gt;

&lt;h4 id=&quot;lecture-16&quot;&gt;Lecture 16&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Knowledge engineering is declarative (not procedural).&lt;/li&gt;
  &lt;li&gt;Propositional and first-order logic are monotonic:
    &lt;ul&gt;
      &lt;li&gt;As new sentences α are added to KB what is entailed can never decrease.&lt;/li&gt;
      &lt;li&gt;Non-monotonic logic eliminates this restriction.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4 efforts of knowledge sharing:
    &lt;ul&gt;
      &lt;li&gt;Knowledge Interchange Format (KIF): Translate from KB1 to KIF then to KB2;&lt;/li&gt;
      &lt;li&gt;Knowledge Representation System Specification: Create “standard” specification for KR language within a particular family of languages;&lt;/li&gt;
      &lt;li&gt;Standardized Query Interface: Share across KBs by querying from one KB to the other (as in databases);&lt;/li&gt;
      &lt;li&gt;Shared, Reusable Knowledge Bases: Create a common “upper” ontology that can form the basis for many knowledge based systems.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4 possible KRR (knowledge representation and reasoning) approaches:
    &lt;ul&gt;
      &lt;li&gt;Knowledge engineering: Write down all of the necessary knowledge in a manner that supports automated inference;
        &lt;ul&gt;
          &lt;li&gt;Cyc / OpenMind Common Sense&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Semantic web: Distribute the knowledge engineering task across the entire world, supported by international standards for encoding knowledge;
        &lt;ul&gt;
          &lt;li&gt;WikiData&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Knowledge extraction: Find knowledge in natural language text (e.g. social media), and convert it into a representation that supports automated reasoning;
        &lt;ul&gt;
          &lt;li&gt;Hearst Patterns / Commonsense axioms from text&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Experiential learning: Build a robot that can learn the knowledge by interacting with the world, just like a human child does;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-17&quot;&gt;Lecture 17&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Situation Calculus:
    &lt;ul&gt;
      &lt;li&gt;Situations: Each time step is a “situation”. A function Result(a, s) gives the situation resulting from applying action a in situation s;&lt;/li&gt;
      &lt;li&gt;Fluents: Functions &amp;amp; predicates whose truth values can change from one situation to the other;&lt;/li&gt;
      &lt;li&gt;Atemporal (or eternal) predicates and functions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Classical issues:
    &lt;ul&gt;
      &lt;li&gt;Frame problem: Representing all things that stay the same from one situation to the next;&lt;/li&gt;
      &lt;li&gt;Qualification problem: Defining the circumstances under which an action is guaranteed to work;&lt;/li&gt;
      &lt;li&gt;Ramification problem: Proliferation of implicit consequences of actions as actions may have secondary consequences.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;STRIPS-style planning:
    &lt;ul&gt;
      &lt;li&gt;Representing states:
        &lt;ul&gt;
          &lt;li&gt;A conjunction of positive literals (must be grounded and function free);&lt;/li&gt;
          &lt;li&gt;Closed world assumption: If not explicitly mentioned as true, assumed false.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Representing goals:
        &lt;ul&gt;
          &lt;li&gt;Generally a partial state specification (still must be positive, grounded and function free);&lt;/li&gt;
          &lt;li&gt;A goal is satisfied if state contains all literals in goal.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Representing actions:
        &lt;ul&gt;
          &lt;li&gt;An action is specified by a name, a list of parameters, a precondition and an effect:
            &lt;ul&gt;
              &lt;li&gt;PRECOND: Must be true in state for action to execute (conjunction of function-free positive literals);&lt;/li&gt;
              &lt;li&gt;EFFECT: Changes to state when action executes (conjunction of function-free literals); Positive literals add facts, negated literals remove facts.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Assumption: Every literal not modified by EFFECT remains unchanged to avoids representational frame problem.&lt;/li&gt;
      &lt;li&gt;Planning Domain Definition Language (PDDL) is slightly more expressive (allows negative literals in goals and preconditions):
        &lt;ul&gt;
          &lt;li&gt;Neither language allows functions;&lt;/li&gt;
          &lt;li&gt;Neither deals with the ramification problem;&lt;/li&gt;
          &lt;li&gt;Neither deals with the qualification problem.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Forward: Progression planner / Backward: Regression planner. Both progression and regression are still NP-hard.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Partial-order planning (POP):
    &lt;ul&gt;
      &lt;li&gt;Each plan has 4 components:
        &lt;ul&gt;
          &lt;li&gt;A set of actions (steps in the plan);&lt;/li&gt;
          &lt;li&gt;A set of ordering constraints: A &amp;lt; B (A before B);&lt;/li&gt;
          &lt;li&gt;A set of causal links (protection intervals);&lt;/li&gt;
          &lt;li&gt;A set of open preconditions (goals).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Planning graph:
    &lt;ul&gt;
      &lt;li&gt;A planning graph consists of a sequence of levels that correspond to steps in the plan; each level consists of a set of literals and a set of actions:
        &lt;ul&gt;
          &lt;li&gt;Literals = all those that could be true at that time step, based on the actions executed at preceding time steps;&lt;/li&gt;
          &lt;li&gt;Actions = all those actions that could have their preconditions satisfied at that time step, based on which literals actually hold;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Connect preconditions of actions in A0 to S0 and effects to S1; Inaction is represented by persistence actions (like frame axioms);&lt;/li&gt;
      &lt;li&gt;Conflicts:
        &lt;ul&gt;
          &lt;li&gt;A mutex relation holds between two actions when:
            &lt;ul&gt;
              &lt;li&gt;Inconsistent effects: one action negates the effect of another;&lt;/li&gt;
              &lt;li&gt;Interference: an effect of one action negates a precondition of the other;&lt;/li&gt;
              &lt;li&gt;Competing needs: a precondition of one action is mutually exclusive with a precondition of the other;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;A mutex relation holds between two literals when:
            &lt;ul&gt;
              &lt;li&gt;One is the negation of the other;&lt;/li&gt;
              &lt;li&gt;Each possible action pair that could achieve the literals is mutex;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Stop when two consecutive levels are identical; complexity is polynomial.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课程所使用的教材是 Artificial Intelligence: A Modern Approach，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。</summary></entry><entry><title type="html">算法期中复习笔记</title><link href="/2018/10/09/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="算法期中复习笔记" /><published>2018-10-09T21:00:00-07:00</published><updated>2018-10-09T21:00:00-07:00</updated><id>/2018/10/09/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="/2018/10/09/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.html">&lt;p&gt;这门课程所使用的教材是康奈尔的 Algorithm Design 和 MIT 的 Introduction to Algorithms，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。&lt;/p&gt;

&lt;h4 id=&quot;lecture-1&quot;&gt;Lecture 1&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;we say f(n) = O(g(n)) if g(n) eventually dominates f(n). Formally: there exists a constant c such that for all sufficiently large n: f(n) ≤ c * g(n). The definition for Ω is similar to the definition for O. If f(n) = O(g(n)) and f(n) = Ω(g(n)), then f(n) = Θ(g(n)).
    &lt;ul&gt;
      &lt;li&gt;(1/3)^n + 100 = O(1) is True.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The handshaking theorem: 2 * E = Σx∈V deg(x) (undirected graph)&lt;/li&gt;
  &lt;li&gt;Adjacency List Representation is used for representation of the sparse (E = O(V)) graphs; Adjacency Matrix Representation is used for representation of the dense (E = Ω(V^2)) graphs.
    &lt;ul&gt;
      &lt;li&gt;Maximally sparse connected graph: tree;&lt;/li&gt;
      &lt;li&gt;Maximally dense connected graph: complete graph Kn.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Linear time topological sort for DAG algorithm:
    &lt;ul&gt;
      &lt;li&gt;Select a vertex;&lt;/li&gt;
      &lt;li&gt;Run DFS and return vertices that has no undiscovered leaving edges;&lt;/li&gt;
      &lt;li&gt;May run DFS several times.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Is strongly connected graphs:
    &lt;ul&gt;
      &lt;li&gt;Select a vertex;&lt;/li&gt;
      &lt;li&gt;Run DFS, if some vertices are not reachable, stop;&lt;/li&gt;
      &lt;li&gt;Construct GT and run DFS again, if some vertices are not reachable, stop.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Euler’s Formula: If G is a connected planar graph, then V – E + F = 2 (proof is by induction).&lt;/li&gt;
  &lt;li&gt;4 Color Theorem: Any simple planar graph can be colored with less than or equal to 4 colors.&lt;/li&gt;
  &lt;li&gt;A graph is bipartite if the vertices can be partitioned into two disjoint sets. A subset of edges is a matching if no two edges have a common vertex.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-2&quot;&gt;Lecture 2&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Complete Binary Tree: completely filled, except the bottom level that is filled from left to right; and a binary heap is a complete binary tree which satisfies the heap ordering property.&lt;/li&gt;
  &lt;li&gt;In heap, consider the k-th element of the array:
    &lt;ul&gt;
      &lt;li&gt;Its left child is located at 2 * k index;&lt;/li&gt;
      &lt;li&gt;Its right child is located at 2 * k + 1 index;&lt;/li&gt;
      &lt;li&gt;Its parent is located at k / 2 index.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap operations:
    &lt;ul&gt;
      &lt;li&gt;Insert: insert at the end, then percolate it up by swapping positions with the parent, if it’s necessary;&lt;/li&gt;
      &lt;li&gt;deleteMin: move the last element of the heap to the root and then restore the heap property by percolating down; So the complexity for heap sort is O(n * log n)&lt;/li&gt;
      &lt;li&gt;decreaseKey: restore a heap property by percolating up this item;&lt;/li&gt;
      &lt;li&gt;buildHeap: by insertion: O(n * log n); heapify: O(n).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Binomial heap operations:
    &lt;ul&gt;
      &lt;li&gt;merge: make the larger root to be the child of the smaller root. Complexity: O(log n);&lt;/li&gt;
      &lt;li&gt;deleteMin: find the binomial tree that contains the min; delete the root and move subtrees to top list; then merge the binomial trees. Complexity: O(log n);&lt;/li&gt;
      &lt;li&gt;insert: merge trees.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Amortized analysis gives the average performance (over time) of each operation in the worst case.
    &lt;ul&gt;
      &lt;li&gt;The amortized cost of insertion of Binomial heap is constant O(2).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Complexities:&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Binary&lt;/th&gt;
      &lt;th&gt;Binomial&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;findMin&lt;/td&gt;
      &lt;td&gt;Θ(1)&lt;/td&gt;
      &lt;td&gt;Θ(1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;deleteMin&lt;/td&gt;
      &lt;td&gt;Θ(log n)&lt;/td&gt;
      &lt;td&gt;Θ(log n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;insert&lt;/td&gt;
      &lt;td&gt;Θ(log n)&lt;/td&gt;
      &lt;td&gt;Θ(1) (amortized complexity)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;decreaseKey&lt;/td&gt;
      &lt;td&gt;Θ(log n)&lt;/td&gt;
      &lt;td&gt;Θ(log n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;merge&lt;/td&gt;
      &lt;td&gt;Θ(n)&lt;/td&gt;
      &lt;td&gt;Θ(log n)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;lecture-3&quot;&gt;Lecture 3&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Scheduling Problem: early finish time first. Complexity: O(n * log n).&lt;/li&gt;
  &lt;li&gt;Minimum Spanning Tree:
    &lt;ul&gt;
      &lt;li&gt;Kruskal’s Algorithm: Continue choosing the minimum weight edge that will not create a cycle until all vertices are connected.
        &lt;ul&gt;
          &lt;li&gt;Sorting edges: O(E * log E);&lt;/li&gt;
          &lt;li&gt;Cycle detection: O(V);&lt;/li&gt;
          &lt;li&gt;Total: O(E * log E + E * V).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Prim’s Algorithm: Start with an arbitrary vertex as a sub-tree C; Expand C by adding a vertex having the minimum weight edge of the graph having exactly one end point in C; Update distances from C to adjacent vertices; Continue doing this until all vertices are connected.
        &lt;ul&gt;
          &lt;li&gt;If we use an array to maintain vertices distance to C, then findMin / deleteMin needs O(V), and update needs O(1). Complexity: O(V ^ 2 + E);&lt;/li&gt;
          &lt;li&gt;If we use a heap, then findMin / deleteMin needs O(log V), and update needs O(log V). Complexity: O(V * log V + E * log V);&lt;/li&gt;
          &lt;li&gt;If graph is dense -&amp;gt; array; if graph is sparse -&amp;gt; heap.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;If a connected undirected graph G = (V, E) has V + 10000 edges, we can find an MST of G in O(V) runtime.
        &lt;ul&gt;
          &lt;li&gt;True. Randomly generate a spanning tree (O(n)), for each edge in the last 10000 edges, add it to the tree, delete the max edge in the cycle (O(n)). So the total complexity should be 10000 * O(n) = O(n).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The Shortest Path Problem:
    &lt;ul&gt;
      &lt;li&gt;Dijkstra’s Algorithm: almost identical to Prim’s algorithm, but picks the shortest path from the source. It’s complexity is same as Prim’s Algorithm.
        &lt;ul&gt;
          &lt;li&gt;If priority queue is an array: O(V ^ 2 + E);&lt;/li&gt;
          &lt;li&gt;If priority queue is a heap: O(V * log V + E * log V);&lt;/li&gt;
          &lt;li&gt;If graph is dense (E = V ^ 2) -&amp;gt; array O(V ^ 2); if graph is sparse -&amp;gt; heap O(V * log V)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-4&quot;&gt;Lecture 4&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The Master Theorem: T(n) = a * T(n / b) + f(n), where a ≥ 1 and b &amp;gt; 1 are constants and f(n) is a positive function, c = logb(a):
    &lt;ul&gt;
      &lt;li&gt;Case 1: if f(n) = O(n^(c-ε)), then T(n) = Θ(n ^ c); (only leaves)&lt;/li&gt;
      &lt;li&gt;Case 2: if f(n) = Θ(n^c * (log n) ^ k), k ≥ 0, then T(n) = Θ(n^c * (log n)^(k + 1)); (all nodes)&lt;/li&gt;
      &lt;li&gt;Case 3: if f(n) = Ω(n^(c+ε)), then T(n) = Θ(f(n)); (only internal nodes)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Closest pair of points: T(n) = 2 * T(n / 2) + O(n * log n), so the complexity should be Θ(n * (log n) ^ 2)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-5&quot;&gt;Lecture 5&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Two Approaches for DP:
    &lt;ul&gt;
      &lt;li&gt;Memoization: a top-down approach;&lt;/li&gt;
      &lt;li&gt;Tabulation: a bottom-up approach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pseudo-Polynomial Algorithm: A numeric algorithm runs in pseudo-polynomial time if its running time is polynomial in the numeric value of the input, but is exponential in the length of the input: T(n) = Θ(n·W).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;lecture-6&quot;&gt;Lecture 6&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Basic steps for DP:
    &lt;ul&gt;
      &lt;li&gt;Define subproblems;&lt;/li&gt;
      &lt;li&gt;Write the recurrence relation;&lt;/li&gt;
      &lt;li&gt;Construct the solution in bottom-up way;&lt;/li&gt;
      &lt;li&gt;Compute its runtime complexity.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bellman-Ford Algorithm:
    &lt;ul&gt;
      &lt;li&gt;How would you apply the Bellman-Ford algorithm to find out if a graph has a negative cycle? Run 1 more round for k = V, if the distance reduced for some point, there must be a negative cycle.&lt;/li&gt;
      &lt;li&gt;Complexity: O(E * V).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D[v, 0] = INFINITY for all v != s
D[s, k] = 0 for all k
for k = 1 to V-1 do
  for each v in V do
    for each neighbor w of v do
      D[v, k] = min(D[v, k - 1], c(w, v) + D[w, k - 1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Floyd-Warshall Algorithm:
    &lt;ul&gt;
      &lt;li&gt;If the diagonal has negative numbers, then there must be a negative cycle.&lt;/li&gt;
      &lt;li&gt;How do we extract the shortest path? Every time we update D[i, j], we set P[i, j] to k. Then we recursively compute the shortest path from from i to k = P[i, j] and the path from from k = P[i, j] to j.&lt;/li&gt;
      &lt;li&gt;Complexity: O(V ^ 3)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D[i, j, 0] = c[i, j] for all i and j
for k = 1 ... V do
  for i = 1 ... V do
    for j = 1 ... V do
      D[i, j, k] = min (D[i, j, k - 1], D[i, k, k - 1] + D[k, j, k - 1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="学习笔记" /><summary type="html">这门课程所使用的教材是康奈尔的 Algorithm Design 和 MIT 的 Introduction to Algorithms，本份笔记直接沿用书本中对变量及名词的定义，在此没有对它们进行特殊解释。</summary></entry></feed>